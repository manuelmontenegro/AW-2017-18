<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tema 3 - Javascript</title>


    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/aw.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/magula.css">


    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);

    </script>

    <link rel="stylesheet" href="css/traspas.css" />
</head>

<body>
    <svg width="0" height="0" style="float:left">
        <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refx="0" refy="3" orient="auto" markerUnits="strokeWidth" style="display:float">
                <path d="M0,0 L0,6 L9,3 z" fill="#000" />
            </marker>
        </defs>
    </svg>
    <div class="reveal">
        <div class="slides">
            <section data-background-image="images/RedBackground.jpg" data-background-transition="fade">
                <div class="headerlesson">Tema 3</div>
                <h1 style="height:3em;position:relative;top:0.3em">Programación en JavascriPT</h1>
                <div class="headerlesson">
                    Aplicaciones Web - GIS - Curso 2017/18
                </div>
                <div class="author">
                    <span class="myname">Manuel Montenegro</span> [<a href="mailto:montenegro@fdi.ucm.es" style="color:white">montenegro@fdi.ucm.es</a>]
                    <br/> Dpto de Sistemas Informáticos y Computación
                    <br/> Facultad de Informática
                    <br/> Universidad Complutense de Madrid
                </div>
                <div class="cc">
                    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
                    <br/> Esta obra está bajo una
                    <br/><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="color:white">Licencia CC BY-NC-SA 4.0 Internacional</a>.
                </div>
                <div style="clear:left;font-size:15px"></div>
            </section>

            <section data-background-image="images/RedBackground.jpg" data-background-transition="fade" id="p1">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline fragment highlight-orange">Introducción</a></li>
                    <li><a href="#/p2" class="outline">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>

            <section>
                <h2>El lenguaje Javascript</h2>
                <p>Javascript fue creado por Brendan Eich en 1995, para ser incluido en el navegador <em>Netscape</em>.</p>
                <p><em>Netscape</em> colaboraba en aquel momento con la empresa <em>Sun Microsystems</em>, propietaria por entonces del lenguaje Java.</p>
                <p>Concebido inicialmente como un <strong>lenguaje &laquo;pegamento&raquo;</strong>, destinado a integrar los distintos componentes de las páginas web: applets, plugins, etc.</p>
                <p class="fragment" style="font-style:italic">Pero su destino fue bien distinto...</p>
            </section>

            <section>
                <h3>Principales hitos en la historia de Javascript</h3>
                <ul>
                    <li>1997 - <strong>HTML Dinámico</strong>
                        <br/> Los programas modifican dinámicamente la estructura de un documento HTML mediante la manipulación de su DOM.
                    </li>
                    <li class="fragment">2005 - <strong>AJAX</strong>
                        <br> Los programas pueden realizar peticiones al servidor desde Javascript, lo que impulsó el paradigma de aplicaciones web de una sola página (SPA).
                    </li>
                    <li class="fragment">
                        2009 - <strong>Node.js</strong>
                        <br> Permite utilizar Javascript en el lado del servidor.
                    </li>
                </ul>
            </section>

            <section>
                <h3>Javascript y ECMAScript</h3>
                <p>En el año 1996 Netscape decidió estandarizar Javascript.</p>
                <p>El estándar fue publicado por la organización <em>Ecma International</em>. El nombre del estándar era <strong>ECMAScript</strong>.</p>
                <p>La versión actual del estándar (8ª edición) es ECMAScript 2017 y fue publicada en junio de 2017.</p>

            </section>

            <section>
                <h3>Javascript en el navegador</h3>
                <p>Los principales navegadores contienen un <strong>intérprete</strong> que permite ejecutar los programas Javascript incluidos en las páginas web.</p>
                <p>El componente del navegador encargado de esto recibe el nombre de <strong>motor Javascript</strong>.</p>
                <div class="fragment">
                    <p>Motores Javascript más conocidos:</p>
                    <ul>
                        <li><strong>SpiderMonkey</strong>, utilizado en Firefox.</li>
                        <li><strong>V8</strong>, utilizado en Chrome.</li>
                        <li><strong>Chakra</strong>, utilizado en Edge.</li>
                    </ul>
                </div>
            </section>

            <section>
                <h3>¿Y Node.js?</h3>
                <p>Es un intérprete del lenguaje Javascript, pensado para ejecutarse <strong>fuera de un navegador</strong>.</p>
                <p>Su implementación está basada en el motor <strong>V8</strong> de Chrome.</p>
                <p>Se utiliza principalmente para implementar las funcionalidades del lado del servidor en aplicaciones web.</p>
                <img src="images/intro/nodejs.png" style="width:30%; border:none; box-shadow:none">
            </section>

            <section>
                <h3>Javascript más allá de la web</h3>
                <ul>
                    <li><strong>Aplicaciones de escritorio</strong>, mediante Node y Electron.
                        <br> Ejemplos: Atom, Visual Studio Code, etc.
                    </li>
                    <li><strong>Aplicaciones móviles</strong>, mediante Apache Cordova.</li>
                    <li><strong>Extensiones de entornos de escritorio</strong>, como GNOME Shell o Windows 10.</li>
                </ul>
            </section>

            <section>

                <section>
                    <h3>Un programa de ejemplo</h3>
                    <pre><code data-trim class="javascript">
// planets.js
// ----------

"use strict";

let planetas = [
    "Mercurio", "Venus", "Tierra",
    "Marte", "Júpiter", "Saturno",
    "Urano", "Neptuno"
    ];

planetas.forEach(p => {
    console.log(`¡Hola, ${p}!`);
});                </code></pre>
                </section>

                <section>
                    <h4>Ejecución desde Node</h4>
                    <p>Si se tiene Node instalado, basta con ejecutar desde una línea de comandos:</p>
                    <pre><code data-trim class="no-highlight">
node planets.js
                </code></pre>
                    <img src="images/03/NodeExec.png" style="width:60%; border:none">
                </section>

                <section>
                    <h4>Ejecución desde un navegador</h4>
                    <p>Si, alternativamente, se quiere ejecutar un programa desde el navegador, ha de importarse el fichero <em>Javascript</em> desde un documento HTML, y abrir éste último desde el navegador.</p>
                    <pre><code data-trim class="html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;script src=&quot;planets.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Abre las herramientas del desarrollador y recarga la p&aacute;gina
        para visualizar el resultado del programa.
    &lt;/body&gt;
&lt;/html&gt;
                </code></pre>
                </section>

                <section>
                    <p>Una vez cargada la página, abrir la consola de Javascript.</p>
                    <p>En Firefox: <em>Desarrollador &rarr; Consola Web</em> (Ctrl + Mayús + K)</p>
                    <p>En Chrome: <em>Herramientas del desarrollador</em> &rarr; <em>Consola</em></p>
                    <img src="images/03/NavegadorExec.png" style="width:60%;border:none">
                </section>
            </section>

            <section>
                <section>
                    <h3>¿<code style="text-transform:none">"use strict"</code>?</h3>
                    <p>Javascript es un lenguaje muy flexible.</p>
                    <p class="fragment">...pero esto conlleva una gran responsabilidad.</p>
                    <p class="fragment">Javascript tiene algunas características que hacen que el lenguaje sea, a veces, <strong>demasiado permisivo</strong>.</p>
                    <p class="fragment">Esto hace que programar en Javascript fuese una tarea propensa a errores.</p>
                </section>

                <section>
                    <p>Introduciendo la cadena <code>"use strict"</code> al principio del programa hace que éste se evalúe en <strong>modo estricto</strong>.</p>
                    <p>Este modo hace que el compilador detecte y prohíba el uso de características demasiado permisivas del lenguaje:</p>
                    <ul>
                        <li>Utilizar variables sin declararlas.</li>
                        <li>Borrar una variable mediante <code>delete</code>.</li>
                        <li>Duplicidades en nombres de atributos y parámetros.</li>
                        <li>Estructuras poco recomendables: <code>with</code>.</li>
                    </ul>
                </section>
            </section>



            <section data-background-image="images/RedBackground.jpg" data-background-transition="zoom" id="p2">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline">Introducción</a></li>
                    <li><a href="#/p2" class="outline current">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>

            <section>
                <h2>El &laquo;Java&raquo; en Javascript</h2>
                <p>
                    La sintaxis de Javascript está inspirada en la de Java.
                </p>
                <ul>
                    <li class="fragment">
                        Comentarios:
                        <pre><code data-trim class="javascript">
// Comentario de una línea
/* Comentario de varias
   líneas */
                        </code></pre>
                    </li>
                    <li class="fragment">Declaraciones de variables y asignaciones:
                        <pre><code data-trim class="javascript">
let x = 3;
let y = x + 1;
y += 3;
                    </code></pre>
                    </li>
                    <li class="fragment">Pre/postincremento, pre/postdecremento:
                        <pre><code data-trim class="javascript">
z = x++;
--x;
                    </code></pre>
                    </li>

                </ul>
            </section>

            <section>
                <h3>Declaración de variables</h3>
                <p>Hay distintas variantes:</p>
                <ul>
                    <li class="fragment">
                        Declaraciones <code>const</code> para constantes.
                        <pre><code data-trim class="javascript">
const x = 1;
                    </code></pre> Su valor no puede cambiar a lo largo del programa.
                    </li>
                    <li class="fragment">
                        Declaraciones <code>let</code> y <code>var</code> para variables.
                        <pre><code data-trim class="javascript">
let x = 1;
var x = 1;
                    </code></pre> Se recomienda el uso de <code>let</code>, porque tienen una noción de ámbito más &laquo;familiar&raquo; para programadores/as que provienen de otros lenguajes.
                    </li>
                </ul>
            </section>

            <section>
                <h3>Sentencias condicionales</h3>
                <ul style="width:20em">
                    <li class="fragment">
                        If-then-else:
                        <pre><code data-trim class="javascript">
if (x &lt; y) {
    return x;
} else {
    return y;
}
                        </code></pre>
                    </li>
                    <li class="fragment">
                        Switch:
                        <pre><code data-trim class="javascript">
switch(day) {
    case 6:
    case 7:
        console.log("Es fin de semana");
        break;
    default:
        console.log("Es día laborable");
}
                        </code></pre>
                    </li>
                </ul>
            </section>

            <section>
                <h3>Bucles</h3>
                <ul style="width:20em">
                    <li class="fragment">Bucle while:
                        <pre><code data-trim class="javascript">
while (x &lt;= 0) {
    n = n * x;
    x--;
}
                    </code></pre>
                    </li>
                    <li class="fragment">Bucle do-while:
                        <pre><code data-trim class="javascript">
do {
    mult *= a[x];
    x++:
} while (a[x] === 0)
                    </code></pre>
                    </li>
                </ul>
            </section>

            <section>
                <ul style="width:20em">
                    <li>
                        Bucles for:
                        <pre><code data-trim class="javascript">
for (let i = 0; i &lt; b.length; i++) {
    sum += b[i] + c[i];
}
                        </code></pre>
                    </li>
                    <li>Bucles for...of para recorrer arrays:
                        <pre><code data-trim class="javascript">
let arr = [4, 6, 10];
let sum = 0;
for (let x of arr) {
    sum += x;
}
                        </code></pre>

                    </li>
                </ul>
                <p style="background-color:#dbb2d5;padding: 5px 0px" class="fragment"><strong>Evita utilizar los bucles for...<span class="hl">in</span></strong></p>
            </section>

            <section>
                <ul style="width:20em">
                    <li>
                        break y continue:
                        <pre><code data-trim class="javascript">
while (i &lt; x.length) {
    if (x[i] === ".") break;
    i++;
}

                        </code></pre>
                        <pre><code data-trim class="javascript">
for (let i = 0; i &lt; x.length; i++) {
    if (x[i] % 2 === 0)
        continue;
    z *= x[i];
}
                        </code></pre>
                    </li>
                </ul>
            </section>

            <section>
                <h3>Funciones</h3>
                <ul style="width: 100%">
                    <li class="fragment">Definición de funciones:
                        <pre><code data-trim class="javascript">
    function abs(x) {
        if (x &lt; 0) {
            return x;
        } else {
            return -x;
        }
    }
                    </code></pre>
                    </li>
                    <li class="fragment">
                        Llamadas a funciones y métodos:
                        <pre><code data-trim class="javascript">
x = abs(-3);
console.log(`El valor absoluto de x es ${x}`);
                </code></pre>
                    </li>
                </ul>
            </section>

            <section>
                <h3>Manejo de excepciones</h3>
                <ul style="width:100%">
                    <li class="fragment">
                        Bloques try-catch o try-catch-finally:
                        <pre><code data-trim data-noescape class="javascript">
try {
   funcion_no_existe();
} catch (e) {  <span class="arrow_box_left caja_codigo fragment" style="position:relative;left:5em">No se especifica el tipo de excepción</span>
    console.error(e.message);
} finally {
    console.log("Esto se ejecuta siempre");
}
                        </code></pre>
                    </li>
                    <li class="fragment">
                        Lanzamiento de excepciones:
                        <pre><code data-trim class="javascript">
throw new Error("Fichero no encontrado");
                        </code></pre>
                    </li>
                    <li class="fragment">
                        Atributos de <code>Error</code>:
                        <ul>
                            <li><code>Error.message</code>: mensaje de error.</li>
                            <li><code>Error.stack</code>: pila de ejecución.</li>
                            <li><code>Error.name</code>: nombre de la clase del error.</li>
                        </ul>
                    </li>
                </ul>
            </section>

            <section>
                <h3>Cadenas de texto</h3>
                <ul style="float:left; width:45%">
                    <li>Inicialización:
                        <pre><code data-trim class="javascript">
let str = "Esto es una cadena";
                    </code></pre> o bien
                        <pre><code data-trim class="javascript">
let str = 'Esto es una cadena';
                    </code></pre>
                    </li>
                    <li>
                        Acceso al carácter i-ésimo:
                        <pre><code data-trim data-noescape class="javascript">
str[2]  <span class="no_arrow_box caja_codigo fragment">!</span> // &rarr; "t"
                        </code></pre>
                    </li>
                </ul>
                <ul style="float:right; width:45%" class="fragment">
                    <li>Métodos:
                        <pre><code data-trim class="javascript">
str.slice(2, 5);
    // &rarr; "to es"
"  vale ".trim();
    // &rarr; "vale"
str.split(" ");
    // &rarr; ["Esto", "es",
    //    "una", "cadena"]
str.toUpperCase();
    // &rarr; "ESTO ES UNA CADENA"
str.toLocaleUpperCase();
    // &rarr; "ESTO ES UNA CADENA"
str.startsWith("Est");
    // &rarr; true
"ab".repeat(5);
    // &rarr; "ababababab"
                    </code></pre>
                    </li>
                </ul>
                <div style="clear:both"></div>
            </section>

            <section>
                <h4>Cadenas plantilla</h4>
                <p>Si delimitamos una cadena entre comillas invertidas (<code>`</code>), podemos utilizar la sintaxis <code>${...}</code> para introducir expresiones Javascript en su contenido.</p>
                <pre><code data-trim class="javascript">
let nombre = "Araceli";
let edad = 27;
let cadena = `Me llamo ${nombre} y tengo ${edad} años`;
console.log(cadena);
    // &rarr; Me llamo Araceli y tengo 27 años
    
console.log(`Pero el año que viene tendré ${edad + 1} años`);
    // &rarr; Pero el año que viene tendré 28 años
                    </code></pre>

            </section>

            <section>
                <h3>Operadores</h3>
                <ul style="position:relative; top: 1em">
                    <li>Relacionales:
                        <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code>,
                        <code>&lt;</code>, <code>&lt;=</code>,
                        <code>&gt;</code>, <code>&gt;=</code>
                        <span class="no_arrow_box caja_codigo fragment" style="position:relative; top:-1.3em;left:-10em">!</span>
                        <span class="no_arrow_box caja_codigo fragment" style="position:relative; top:-1.3em;left:-7.4em">!</span>

                    </li>

                    <li>
                        Aritméticos:
                        <code>+</code>, <code>-</code>, <code>*</code>,
                        <code>/</code>, <code>%</code>
                    </li>

                    <li>
                        Lógicos:
                        <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>
                    </li>
                    <li>
                        A nivel de bit:
                        <code>&amp;</code>, <code>|</code>, <code>^</code>,
                        <code>&gt;&gt;</code>, <code>&lt;&lt;</code>,
                        <code>&gt;&gt;&gt;</code>
                    </li>

                </ul>
            </section>


            <section>
                <h3>Arrays</h3>
                <ul style="width:100%">
                    <li>Inicialización:
                        <pre><code data-trim data-noescape class="javascript">
let x = [4, 6, "pepe", 1, 3];   <span class="arrow_box_left caja_codigo fragment">Corchetes en lugar de { }</span>

let z = [];   <span class="arrow_box_left caja_codigo fragment" style="position:relative;">Vector vacío</span>

let m = new Array(3);
                    </code></pre>
                    </li>
                    <li class="fragment">Acceso:
                        <pre><code data-trim class="javascript">
console.log(x[3]);  // &rarr; 1
m[2] = "Elemento nuevo";
                        </code></pre>
                    </li>
                    <li class="fragment">
                        Longitud:
                        <pre><code data-trim class="javascript">
x.length  // &rarr; 5
z.length  // &rarr; 0
m.length  // &rarr; 3
                        </code></pre>
                    </li>
                </ul>
            </section>

            <section data-background-image="images/RedBackground.jpg" data-background-transition="zoom" id="p3">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline">Introducción</a></li>
                    <li><a href="#/p2" class="outline">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline current">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>

            <section>
                <h2 style="margin-bottom:0px;">Once rarezas de Javascript</h2>
                <p><strong>(para alguien que viene de Java)</strong></p>
                <ol style="font-size: 90%">
                    <li>Javascript es dinámicamente tipado.</li>
                    <li>Los objetos no son necesariamente instancias de clases.</li>
                    <li>Valores indefinidos, nulos y <code>NaN</code>.</li>
                    <li>Las conversiones invisibles.</li>
                    <li>Argumentos que sobran y faltan.</li>
                    <li>Las funciones son ciudadanos de primera clase.</li>
                    <li>Las clases llegaron veinte años tarde.</li>
                    <li>La herencia basada en prototipos.</li>
                    <li>Los arrays son flexibles, y también son objetos.</li>
                    <li>Las funciones de orden superior sobre arrays.</li>
                    <li>Los módulos aún están por aterrizar.</li>
                </ol>
            </section>

            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 1</span><span style="display:none">:</span><br>Javascript es un lenguaje dinámicamente tipado</h3>
                    </div>
                </section>

                <section>
                    <h3>declaraciones de tipo</h3>
                    <p>En Java es necesario declarar el tipo de una variable antes de su primer uso:</p>
                    <pre><code data-trim class="java">
int x;
String z = "It's something";
List&lt;Integer&gt; lista;
                    </code></pre>

                    <p>En Javascript no se indica el tipo de la variable a declarar. Se utilizan las palabras <code>let</code>, <code>const</code> o <code>var</code>.</p>
                    <pre><code data-trim class="javascript">
let x;
const z = "It's something";
let lista;
                    </code></pre>

                    <div class="fragment" style="color:blue">
                        ¿Qué ventajas e inconvenientes tiene indicar el tipo de las variables en el programa?
                    </div>
                </section>

                <section>
                    <h4>Lenguajes <strong>estáticamente tipados</strong></h4>
                    <ul>
                        <li>
                            <p>Se detecta <strong>en tiempo de compilación</strong> que las operaciones se realizan sobre argumentos del tipo correcto.</p>
                            <p>Por ejemplo, el compilador avisa de errores como:</p>
                            <pre><code data-trim class="javascript">
"pepe" * 24
                            </code></pre>
                        </li>
                        <li>
                            <p>Estos lenguajes pueden requerir declaraciones de tipos por parte del programador.</p>
                            <p>Por ejemplo: Java, C, etc.</p>
                        </li>
                        <li>
                            <p>En algunos lenguajes el compilador <strong>infiere</strong> los tipos.</p>
                            <p>Por ejemplo: Haskell, C++, etc.</p>
                        </li>
                    </ul>
                </section>

                <section>
                    <h4>Lenguajes <strong>dinámicamente</strong> tipados</h4>
                    <ul>
                        <li>
                            <p>Se comprueba <strong>durante la ejecución del programa</strong> que las operaciones se realizan sobre argumentos de tipo correcto.</p>
                            <div class="fragment">
                                <p>Por ejemplo, en Javascript:</p>
                                <pre><code data-trim class="javascript">
if (...) {
    y = 3 * "foo";
}
                            </code></pre>
                                <p>El error debido a la expresión <code>3 * "foo"</code> solamente se manifestará si la condición del <code>if</code> se cumple.</p>
                            </div>
                        </li>

                    </ul>
                </section>
                <section>
                    <h4>Ejemplos</h4>
                    <ul>
                        <li>
                            <p><strong>Lenguajes sin tipos</strong></p>
                            <p style="font-size:70%">Son poco usuales: Tcl, ensamblador, etc.</p>
                        </li>
                        <li class="fragment">
                            <p><strong>Lenguajes estáticamente tipados, no dinámicamente</strong></p>
                            <p style="font-size:70%">C, Haskell, etc.</p>
                        </li>
                        <li class="fragment">
                            <p><strong>Lenguajes dinámicamente tipados, no estáticamente</strong></p>
                            <p style="font-size:70%">Python, <span style="background-color:#C0FFC0; padding:0px 10px">Javascript</span>, PHP, etc.</p>
                        </li>
                        <li class="fragment">
                            <p><strong>Lenguajes estáticamente y dinámicamente tipados</strong></p>
                            <p style="font-size:70%">Java, C++, C#, etc.</p>
                        </li>
                    </ul>
                </section>
                <section>
                    <h4>Tipos disponibles en Javascript</h4>
                    <ul>
                        <li>
                            <p>Tipo numérico (<code>number</code>).</p>
                            <p style="font-size:70%">El sistema de tipos no distingue entre enteros y coma flotante.</p>
                        </li>
                        <li>Tipo booleano (<code>boolean</code>).
                            <p style="font-size:70%">Incluye los valores <code>true</code> y <code>false</code>.</p>
                        </li>
                        <li>Tipo cadena (<code>string</code>).</li>
                        <li>Tipo objeto (<code>object</code>).
                            <p style="font-size:70%">Incluye también a arrays, funciones y expresiones regulares.</p>
                        </li>
                        <li>Tipo del valor indefinido (<code>undefined</code>)</li>
                        <li>Tipo del puntero nulo (<code>null</code>)</li>

                    </ul>
                </section>

                <section>
                    <h4>Tipos primitivos vs tipos objeto</h4>
                    <div style="width:80%;margin-left:auto;margin-right:auto">
                        <ul style="float:left" class="fragment">
                            <li><span style="color:#3080B0; font-weight:bold">Tipos primitivos</span>
                                <ul>
                                    <li>Numérico</li>
                                    <li>Booleano</li>
                                    <li>Cadena</li>
                                    <li>Indefinido</li>
                                    <li>Nulo</li>
                                </ul>
                            </li>
                        </ul>
                        <ul class="fragment">
                            <li><span style="color:#3080B0; font-weight:bold">Tipos objeto</span>
                                <ul>
                                    <li>Objeto</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <p class="fragment" style="clear:both">Veamos cuál es la diferencia.</p>
                </section>
                <section>
                    <p>Los tipos primitivos son <strong>inmutables</strong></p>
                    <pre><code data-trim data-noescape class="javascript">
let str1 = "Cadena";
let str2 = str1.slice(0, 3);      <span class="arrow_box_left caja_codigo">No modifica la cadena <span style="font-family:monospace">str1</span></span>
console.log(str1);  // &rarr; Cadena1
console.log(str2);  // &rarr; Cad
                    </code></pre>
                    <div class="fragment">
                        <p>Las comparaciones entre tipos primitivos se hacen por <strong>valor</strong>, no por referencia</p>
                        <pre><code data-trim data-noescape class="javascript">
let str1 = "Cadena";
let str2 = "Cadena";
let str3 = "Otra cadena";
str1 == str2;   // &rarr; true
str1 === str2;  // &rarr; true
str1 != str3    // &rarr; true
str1 !== str3   // &rarr; true
                    </code></pre>
                        <p>En Java <code>str1 == str2</code> devuelve <code>false</code>, pues son objetos distintos. En cambio, <code>str1.equals(str2)</code> devuelve <code>true</code>.</p>
                    </div>
                </section>

                <section>
                    <p>Las cadenas pueden compararse lexicográficamente mediante los operadores relacionales <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code> y
                        <code>&gt;</code>:</p>
                    <pre><code data-trim class="javascript">
"Pablo" &lt; "Diana"    // &rarr; false
"Pablo" &lt; "Paolo"    // &rarr; true
"alma" &lt;= "Pablo"    // &rarr; false
"Águeda" &lt; "Pablo"   // &rarr; false
                    </code></pre>
                    <p>Se utiliza <code>localeCompare()</code> para comparar según el abecedario del idioma correspondiente.</p>
                    <pre><code data-trim class="javascript">
"alma".localeCompare("Pablo");      // &rarr; -1 ('alma' es menor)
"Sergio".localeCompare("Pablo");    // &rarr; 1  ('Pablo' es menor)
"Sergio".localeCompare("Sergio");   // &rarr; 0  (iguales)
                    </code></pre>
                </section>

                <section>
                    <h4>Comprobación de tipos</h4>
                    <p>La función <code>typeof</code> permite obtener el tipo de un elemento. Devuelve una cadena con el nombre del tipo.</p>
                    <pre><code data-trim class="javascript">
let x = 3;
console.log(typeof(x));                         // &rarr; number
console.log(typeof("Hola"));                    // &rarr; string
console.log(typeof(variable_que_no_existe));    // &rarr; undefined
console.log(typeof(2 &lt; 9));                     // &rarr; boolean
console.log(typeof([1, 3, 5]));                 // &rarr; object
console.log(typeof(null));                      // &rarr; object
                    </code></pre>
                    <p>Aunque <code>null</code> es un tipo básico, <code>typeof(null)</code> devuelve <code>"object"</code>.
                    </p>
                </section>
            </section>

            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 2</span><span style="display:none">:</span><br>Los objetos no tienen por qué ser instancias de clases</h3>
                    </div>
                </section>

                <section>
                    <h4>Objetos en Java</h4>
                    <p>En Java, un objeto es una <strong>instancia de una clase</strong>.
                        <pre><code data-trim class="java">
class Persona {
    public String nombre;
    public String apellidos;
    public int edad;
}
...
p = new Persona();
                   </code></pre>

                        <p>La clase es la que define los atributos y métodos del objeto.</p>
                        <pre><code data-trim data-noescape class="java">
p.nombre = "Ana María";
System.out.println(p.edad);
p.poblacion = "Barcelona";  <span class="arrow_box_left caja_codigo fragment">¡Error! Atributo no declarado en clase</span>
</code></pre>
                </section>
                <section>
                    <h4>Objetos en Javascript</h4>
                    <p>Un <strong>objeto</strong> en Javascript no es más que una colección de <strong style="color:#5050FF">atributos</strong>, cada uno de ellos asociado a un <strong style="color:#5050FF">valor</strong>.</p>
                    <pre><code data-trim class="javascript">
let x = {
    nombre: "Ana María",
    apellidos: "Gamboa Esteban",
    edad: 54
};
                   </code></pre>
                    <p>Aquí se definen los atributos <strong>al crear el objeto</strong>.</p>
                    <div class="fragment">
                        <p>El literal <code>{}</code> representa un objeto vacío (sin atributos)</p>
                        <pre><code data-trim class="javascript">
let y = {};
                    </code></pre>
                    </div>
                </section>

                <section>
                    <p>El acceso a los atributos de un objeto se realiza mediante:</p>
                    <ul style="width: 100%">
                        <li class="fragment">El operador punto (<code>.</code>), igual que en Java.
                            <pre><code data-trim class="javascript">
x.apellidos // &rarr; "Gamboa Esteban"
                            </code></pre>
                        </li>
                        <li class="fragment">o bien, mediante el operador corchete
                            <pre><code data-trim class="javascript">
x["apellidos"] // &rarr; "Gamboa Esteban"
                            </code></pre>
                            <pre class="fragment"><code data-trim class="javascript">
let atrib = "nombre";
x[atrib] // &rarr; "Ana María"
                            </code></pre>
                        </li>
                    </ul>
                    <div class="fragment">
                        <p>El acceso a una propiedad inexistente devuelve <code>undefined</code></p>
                        <pre><code data-trim class="javascript">
x.noexiste  // &rarr; undefined
y.nombre    // &rarr; undefined
                    </code></pre>
                    </div>
                </section>

                <section>
                    <p>Modificación de atributos:</p>
                    <pre><code data-trim class="javascript">
x.edad = x.edad + 1;  // o bien: x.edad++
x["nombre"] = "Ana Josefa";
                    </code></pre>
                    <div class="fragment">
                        <p>Es posible añadir atributos sobre la marcha:</p>
                        <pre><code data-trim class="javascript">
x.direccion = "Calle Bautista, 25";
y.nombre = "Javier";

console.log(x);
 // { nombre: 'Ana Josefa', apellidos: 'Gamboa Esteban', edad: 55,
 //   direccion: "Calle Bautista, 25" }
console.log(y);
 // { nombre: 'Javier' }
                    </code></pre>
                    </div>
                    <div class="fragment">
                        <p>...y también borrarlos:</p>
                        <pre><code data-trim class="javascript">
delete x.edad;
console.log(x);
 // { nombre: 'Ana Josefa', apellidos: 'Gamboa Esteban' }

                    </code></pre>
                    </div>
                </section>

                <section>
                    <p>Los nombres de atributos no han de ser necesariamente identificadores válidos de Javascript. En caso de no serlo, han de aparecer entre comillas en la declaración:</p>
                    <pre><code data-trim class="javascript">
let z = {
    "Atributo con espacios": 21,
    "14": "foo",
    "false": "ok"
};
                    </code></pre>
                    <p>Para acceder a estos atributos solo se puede utilizar la notación corchete</p>
                    <pre><code data-trim class="javascript">
z["Atributo con espacios"] = 22;
                    </code></pre>
                </section>

                <section>
                    <p>La función <code>Object.keys()</code> devuelve un array con los nombres de propiedades de un objeto:</p>
                    <pre><code data-trim class="javascript">
let x = {
    nombre: "Ana María",
    apellidos: "Gamboa Esteban",
    edad: 54
};

console.log(Object.keys(x));
    // [ 'nombre', 'apellidos', 'edad' ]
                    </code></pre>
                    <div class="fragment">
                        <p>El operador <code>in</code> permite determinar la existencia de un atributo dentro de un objeto:</p>
                        <pre><code data-trim class="javascript">
if ("edad" in x) {
    console.log("x tiene un atributo llamado 'edad'");
}
                    </code></pre>
                    </div>
                </section>

                <section>
                    <h4>Igualdad de objetos</h4>
                    <p>Cuando se aplica el operador <code>==</code> o <code>===</code> sobre objetos, se comprueba que las referencias a ambos lados del operador apuntan al mismo objeto (igualdad al estilo de Java)</p>
                    <pre><code data-trim data-noescape class="javascript">
let coords1 = { x: 20, y: 30 };
let coords2 = { x: 20, y: 30 };
let coords3 = coords1;

console.log(coords1 === coords2);
    <span class="fragment">// &rarr; false</span>

console.log(coords1 === coords3);
    <span class="fragment">// &rarr; true</span>
                    </code></pre>
                    <p class="fragment"><strong>Recuerda:</strong> en Javascript, las cadenas no son objetos; son tipos básicos.</p>
                </section>

            </section>

            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 3</span><span style="display:none">:</span><br>Valores indefinidos, nulos, y <span style="text-transform:none">NaN</span></h3>
                    </div>
                </section>

                <section>
                    <div>
                        <h4>El valor indefinido (<code style="text-transform:none">undefined</code>)</h4>
                        <p>Se utiliza para las variables no inicializadas y para atributos no existentes dentro de objetos.</p>
                        <pre><code data-trim class="javascript">
let coordenadas = { x: 5, y: 6 };
let v;
console.log(v);                 // &rarr; undefined
console.log(coordenadas.z);     // &rarr; undefined
                        </code></pre>
                    </div>
                    <div class="fragment">
                        <h4>El valor nulo (<code style="text-transform:none">null</code>)</h4>
                        <p>Se utiliza para denotar una referencia a objeto nula.</p>
                        <pre><code data-trim class="javascript">
let x = null;   // La variable 'x' esta inicializada, pero a una
                // referencia nula.
console.log(x); // &rarr; null
                        </code></pre>
                    </div>
                </section>

                <section>
                    <h4>El valor Not-a-Number (<code style="text-transform:none">NaN</code>)</h4>
                    <p>Se devuelve como resultado de operaciones aritméticas incorrectas:</p>
                    <pre><code data-trim class="javascript">
Math.log(-2)    // &rarr; NaN
parseInt("x2d") // &rarr; NaN
                    </code></pre>
                    <div class="fragment">
                        <h4>Los valores infinitos</h4>
                        <p><code>Infinity</code> y <code>-Infinity</code> se utilizan para desbordamientos, o para operaciones que devuelven &plusmn;&infin;</p>
                        <pre><code data-trim class="javascript">
Math.pow(2, 10000)  // &rarr; Infinity
Math.log(0)         // &rarr; -Infinity
                        </code></pre>
                    </div>
                </section>

                <section>
                    <p>¡Cuidado con las comparaciones con <code>NaN</code>!</p>
                    <pre><code data-trim data-noescape class="javascript">
Math.log(-3) === NaN <span class="fragment">// &rarr; false</span>
NaN === NaN          <span class="fragment">// &rarr; false</span>
                    </code></pre>
                    <div class="fragment">
                        <p>Si se quiere determinar si una operación ha dado <code>NaN</code> como resultado, debe utilizarse la función <code>isNaN</code></p>
                        <pre><code data-trim class="javascript">
isNaN(NaN)          // &rarr; true
isNaN(Math.log(-3)) // &rarr; true
                    </code></pre>
                    </div>
                </section>

            </section>



            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 4</span><span style="display:none">:</span><br>Las conversiones invisibles</h3>
                    </div>
                </section>

                <section>
                    <h4>Conversiones Javascript</h4>
                    <p>¿A qué valor se evalúan las siguientes expresiones?</p>
                    <pre><code data-trim data-noescape class="javascript">
"3" * 4             <span class="fragment">// &rarr; 12</span>
3 * 4               <span class="fragment">// &rarr; 12</span>
"3" * "4"           <span class="fragment">// &rarr; 12</span>
"3" * "pepe"        <span class="fragment">// &rarr; NaN</span>
"12" + "20"         <span class="fragment">// &rarr; 1220</span>
"12" + 20           <span class="fragment">// &rarr; 1220</span>
12 + "20"           <span class="fragment">// &rarr; 1220</span>
Math.log10("1000")  <span class="fragment">// &rarr; 3</span>
"10" &lt; "2"          <span class="fragment">// &rarr; true</span>
"10" &lt; 2            <span class="fragment">// &rarr; false</span>
                    </code></pre>
                </section>

                <section>
                    <p>¿En qué casos se cumple la condición del <code>if</code>?</p>
                    <pre><code data-trim data-noescape class="javascript">
if (23) { .... }            <span class="fragment">// &rarr; se cumple</span>
if (-1) { .... }            <span class="fragment">// &rarr; se cumple</span>
if (0) { .... }             <span class="fragment">// &rarr; no se cumple</span>
if ("Pepe") { .... }        <span class="fragment">// &rarr; se cumple</span>
if ("") { .... }            <span class="fragment">// &rarr; no se cumple</span>
if ([1, 3]) { .... }        <span class="fragment">// &rarr; se cumple</span>
if ([]) { .... }            <span class="fragment">// &rarr; se cumple</span>
if (null) { .... }          <span class="fragment">// &rarr; no se cumple</span>
if (undefined) { .... }     <span class="fragment">// &rarr; no se cumple</span>
                    </code></pre>
                </section>

                <section>
                    <h4>Cómo evitar confusiones</h4>
                    <p>Con este panorama, hay dos alternativas:</p>
                    <ol>
                        <li class="fragment">Aprenderse concienzudamente las reglas de conversión de Javascript:
                            <p>Información: <a href="http://webreflection.blogspot.com.es/2010/10/javascript-coercion-demystified.html">http://webreflection.blogspot.com.es/2010/10/javascript-coercion-demystified.html</a></p>
                        </li>
                        <li class="fragment">
                            <strong>[Recomendado]</strong> Hacer las conversiones explícitamente, en caso de no estar seguro/a del tipo de una expresión
                            <p>Funciones <code>Number(...)</code>, <code>String(...)</code>, <code>Boolean(...)</code></p>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4>Funciones de conversión</h4>
                    <p>La función <code>Number()</code></p>
                    <pre><code data-trim data-noescape class="javascript">
Number("32")        <span class="fragment">// &rarr; 32</span>
Number("2f3")       <span class="fragment">// &rarr; NaN</span>
Number(true)        <span class="fragment">// &rarr; 1</span>
Number(false)       <span class="fragment">// &rarr; 0</span>
Number(undefined)   <span class="fragment">// &rarr; NaN</span>
Number(null)        <span class="fragment">// &rarr; 0</span>
Number(new Date())  <span class="fragment">// &rarr; 1476191814528 (depende de fecha y hora)</span>
                    </code></pre>
                    <p>Cuando la función <code>Number</code> se llama sobre un objeto <code>x</code>, se devuelve <code>x.valueOf()</code>.</p>
                    <p>Ver también: <code>parseInt</code> <a href="http://www.w3schools.com/jsref/jsref_parseint.asp">[+]</a></p>

                </section>

                <section>
                    <p>La función <code>String()</code></p>
                    <pre><code data-trim data-noescape class="javascript">
String(true)       <span class="fragment">// &rarr; "true"</span>
String(undefined)  <span class="fragment">// &rarr; "undefined"</span>
String(32)         <span class="fragment">// &rarr; "32"</span>
String(new Date()) <span class="fragment">// &rarr; "Tue Oct 11 2016 15:23:02 GMT+0200 (CEST)"</span>
                    </code></pre>

                    <p>La función <code>String</code> aplicada sobre un objeto <code>x</code> llama al método <code>x.toString()</code></p>
                </section>

                <section>
                    <p>La función <code>Boolean()</code></p>
                    <ul>
                        <li>Valores falsos: <code>undefined</code>, <code>null</code>, <code>false</code>, <code>0</code>, <code>NaN</code>, <code>""</code>.</li>
                        <li>Valores ciertos: el resto.</li>
                    </ul>

                    <pre><code data-trim data-noescape class="javascript">
Boolean("")         <span class="fragment">// &rarr; true</span>
Boolean(34)         <span class="fragment">// &rarr; false</span>
                    </code></pre>
                </section>


                <section>
                    <h4>Operadores de igualdad</h4>
                    <dl>
                        <dt><code>x === y</code> - Igualdad estricta</dt>
                        <dd><code>x</code> e <code>y</code> son del mismo tipo y tienen el mismo valor.</dd>
                        <dt><code>x == y</code> - Igualdad flexible</dt>
                        <dd><code>x</code> e <code>y</code> pueden convertirse al mismo tipo, de modo que tras hacer la conversión tienen el mismo valor.</dd>
                    </dl>
                    <div class="fragment">
                        <pre><code data-trim data-noescape class="javascript">
"25" == 25      <span class="fragment">// &rarr; true</span>
"25" === 25     <span class="fragment">// &rarr; false</span>
false == 0      <span class="fragment">// &rarr; true</span>
"" == 0         <span class="fragment">// &rarr; true</span>
2.0 === 2       <span class="fragment">// &rarr; true (recuerda: no se distingue entre tipo
                //         de enteros y de coma flotante)</span>

                    </code></pre>
                    </div>
                    <p class="fragment">También se definen <code>!=</code> y <code>!==</code> como la negación de <code>==</code> y <code>===</code> respectivamente.</p>
                </section>

                <section>
                    <h4>Moraleja</h4>
                    <p style="background-color:#007000; color:white; padding: 80px 20px; font-size: 200%">Utiliza siempre
                        <span style="font-family: monospace">===</span> y <span style="font-family: monospace">!==</span></p>
                </section>

            </section>

            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 5</span><span style="display:none">:</span><br>Argumentos que sobran y argumentos que faltan</h3>
                    </div>
                </section>

                <section>
                    <h4>Definición de una función</h4>
                    <pre><code data-trim class="javascript">
function imprime_args(p1, p2, p3) {
    console.log(`p1: ${p1}`);
    console.log(`p2: ${p2}`);
    console.log(`p3: ${p3}`);
}

                    </code></pre>
                    <div class="fragment">
                        <h4>Llamada a una función</h4>
                        <pre><code data-trim class="javascript">
imprime_args(1, "bar", true);
                    </code></pre>
                    </div>
                    <div class="fragment">
                        <p>Resultado:</p>
                        <pre>
p1: 1
p2: bar
p3: true</pre>
                    </div>
                </section>


                <section>
                    <p>El número de argumentos en la llamada a la función no ha de coincidir necesariamente con el número de parámetros en la definición</p>

                    <ul>
                        <li class="fragment">Si se proporcionan argumentos &laquo;de más&raquo; se ignoran los sobrantes:
                            <pre><code data-trim class="javascript">
imprime_args("uno", "dos", "tres", "cuatro");
                        </code></pre>
                            <pre>
p1: uno
p2: dos
p3: tres</pre>
                        </li>
                    </ul>
                </section>
                
                <section>
                    <ul>
                        <li>
                            Si faltan argumentos, los parámetros correspondientes tomarán el valor <code>undefined</code>
                            <pre><code data-trim class="">
imprime_args("uno", "dos");
                            </code></pre>
                            <pre>
p1: uno
p2: dos
p3: undefined</pre>
                        </li>
                    </ul>
                </section>

                <section>
                    <p>Esto nos permite definir funciones con parámetros opcionales.</p>
                    <pre><code data-trim class="javascript">
/*
    El parámetro 'color' es opcional. Su valor por defecto
    es 'negro'.

    El parámetro 'trazo' especifica el grosor del trazo y
    también es opcional. Su valor por defecto es 1.
*/
function pintar_circulo(x, y, color, trazo) {
   if (color === undefined) color = "negro";
   if (trazo === undefined) trazo = 1;

   console.log(`Pintar círculo en (${x}, ${y}) de color ${color}` +
                ` y trazo de grosor ${trazo}`;
}
                   </code></pre>
                </section>

                <section>
                    <p>Aunque hay una sintaxis específica para ello:</p>
                    <pre><code data-trim data-noescape class="javascript">
/*
    El parámetro 'color' es opcional. Su valor por defecto
    es 'negro'.

    El parámetro 'trazo' especifica el grosor del trazo y
    también es opcional. Su valor por defecto es 1.
*/
function pintar_circulo(x, y, <span class="hl">color = "negro"</span>, <span class="hl">trazo = 1</span>) {
   console.log(`Pintar círculo en (${x}, ${y}) de color ${color}` +
                ` y trazo de grosor ${trazo}`;
}
                   </code></pre>
                </section>

                <section>
                    <h4>Parámetros nominales</h4>
                    <p>Utilizando objetos podemos simular el paso de parámetros nominales.</p>
                    <p>Por ejemplo, supongamos una función <code>abrir_fichero</code> que espera un nombre de fichero y, opcionalmente:</p>
                    <ul>
                        <li>
                            <p>Un parámetro <code>solo_lectura</code> que indica si el fichero se abre en modo lectura o en modo lectura/escritura.</p>
                            <p>Valor por defecto: <code>true</code></p>
                        </li>
                        <li>
                            <p>Un parámetro <code>binario</code> que indica si el fichero es binario o no.</p>
                            <p>Valor por defecto: <code>false</code></p>
                        </li>
                    </ul>
                </section>

                <section>
                    <p>Ejemplos de llamadas</p>
                    <pre><code data-trim class="javascript">
abrir_fichero("mio.txt");
// Abriendo fichero mio.txt en modo lectura

abrir_fichero("mio.txt", { solo_lectura: false });
// Abriendo fichero mio.txt en modo lectura/escritura

abrir_fichero("mio.txt", { binario: true });
// Abriendo fichero binario mio.txt en modo lectura

abrir_fichero("mio.txt", { binario: true, solo_lectura: false });
// Abriendo fichero binario mio.txt en modo lectura/escritura

abrir_fichero("mio.txt", { solo_lectura: true, binario: false });
// Abriendo fichero mio.txt en modo lectura
                    </code></pre>
                </section>

                <section>
                    <p>Implementación:</p>
                    <pre><code data-trim class="javascript">
/*
    El objeto 'ops' tiene como atributos los parámetros
    opcionales.
*/
function abrir_fichero(nombre, ops = {}) {
   // Inicialización de los parámetros opcionales no pasados
   if (ops.solo_lectura === undefined) ops.solo_lectura = true;
   if (ops.binario      === undefined) ops.binario      = false;
   
   // Cuerpo de la función
   console.log(`Abriendo fichero ${ops.binario ? "binario " : ""}` +
               `${nombre} en modo ` + 
            (ops.solo_lectura ? "lectura" : "lectura/escritura"))`;

}
                    </code></pre>
                </section>

                <section>
                    <p>Sintaxis alternativa:</p>
                    <pre><code data-trim data-noescape class="javascript">
/*
    El objeto 'ops' tiene como atributos los parámetros
    opcionales.
*/
function abrir_fichero(nombre, 
                <span class="hl">{solo_lectura = true, binario = false}</span> = {}) {
   // Cuerpo de la función
   console.log(`Abriendo fichero ${ops.binario ? "binario " : ""}` +
               `${nombre} en modo ` + 
            (ops.solo_lectura ? "lectura" : "lectura/escritura"))`;

}
                    </code></pre>
                    <p>Más información: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">Destructuring assignment</a></p>
                </section>

            </section>

            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 6</span><span style="display:none">:</span><br>Las funciones son ciudadanos de primera clase</h3>
                    </div>
                </section>

                <section>
                    <h4>¿Qué significa eso?</h4>
                    <p>Que las funciones son tratadas como cualquier otro valor.</p>
                    <p>En particular:</p>
                    <ul style="color:#008dbc">
                        <li class="fragment">Se puede asignar una función a una variable.</li>
                        <li class="fragment">Pueden pasarse funciones como parámetros.</li>
                        <li class="fragment">Pueden recibirse funciones como resultados.</li>
                    </ul>

                    <div class="fragment">
                        <p>Esta característica es compartida por muchos lenguajes funcionales e imperativos:</p>
                        <p>Haskell, Scala, Erlang, C, C++, Java 8, etc.</p>
                    </div>
                </section>

                <section>
                    <p>Partimos de las siguientes definiciones:</p>
                    <pre><code data-trim class="javascript">
function incrementar(x) {
    return x + 1;
}

function duplicar(x) {
    return 2 * x;
}

function cuadrado(y) {
    return y * y;
}

function factorial(n) {
    if (n &lt;= 0) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}
                    </code></pre>
                </section>

                <section>
                    <p>Asignamos algunas de estas funciones a la variable <code>f</code>:</p>
                    <pre><code data-trim class="javascript">
let f = incrementar;
console.log(f(5));
// Imprime: 6

f = factorial;
console.log(f(10));
// Imprime: 3628800
                    </code></pre>
                    <div class="fragment">
                        <p>¡Cuidado con los paréntesis!</p>
                        <pre><code data-trim  data-noescape class="javascript">
let f = incrementar(); <span class="fragment"> // INCORRECTO
// Esto realiza la llamada incrementar(undefined), y asigna el
// valor resultante (que también es undefined) a f.</span>

console.log(f(5));
// ERROR: f no es una función
                    </code></pre>
                    </div>
                </section>


                <section>
                    <p>La siguiente función recibe una lista de funciones y un valor. Aplica cada una de las funciones de la lista al valor dado y muestra los resultados por consola:</p>
                    <pre><code data-trim class="javascript">
function aplicar_funciones(funs, z) {
    for (let i = 0; i &lt; funs.length; i++) {
        console.log(
            `Aplicar función ${i} pasando ${z}: ${funs[i](z)}`
        );
    }
}
                    </code></pre>
                    <div class="fragment">
                        <p>Ejemplo:</p>
                        <pre><code data-trim class="javascript">
aplicar_funciones([incrementar,duplicar,cuadrado,factorial], 5);
                    </code></pre>
                        <pre>
Aplicar función 0 pasando 5: 6
Aplicar función 1 pasando 5: 10
Aplicar función 2 pasando 5: 25
Aplicar función 3 pasando 5: 120</pre>
                    </div>
                </section>

                <section>
                    <p>De igual modo, se puede devolver una función como resultado:</p>
                    <pre><code data-trim data-noescape class="javascript">
function buscar_por_nombre(nombre) {
    switch(nombre) {
        case "INC": return incrementar;
        case "DUP": return dup;
        case "SQR": return cuadrado;
        case "FCT": return factorial;
    }
    <span class="fragment">// Si la función termina sin alcanzar un return,
    // se considera que devuelve undefined</span>
}
                    </code></pre>
                    <div class="fragment">
                        <p>Ejemplo:</p>
                        <pre><code data-trim class="javascript">
var g = buscar_por_nombre("INC");
console.log(g(10));
                    </code></pre>
                        <pre>
11</pre>
                    </div>
                </section>

                <section>
                    <h4>Funciones como expresiones</h4>
                    <p>Se puede utilizar una definición de función en cualquier sitio donde se espere una expresión.</p>
                    <p>En estos casos es posible omitir el nombre de la función (<strong>función anónima</strong>)</p>
                    <pre><code data-trim class="javascript">
let f = function() { console.log("Hola"); };
f();

let g = function(x, y) { return x + y; };
console.log(g(3, 5));
                    </code></pre>
                </section>

                <section>
                    <p>En el ejemplo anterior:</p>
                    <pre><code data-trim class="javascript">
aplicar_funciones(
    [ function(x) { return x - 3; },
      function(x) { return Math.sqrt(x); },
      factorial,
      function(z) { return Math.log(z); }  ], 2);
                    </code></pre>
                    <pre>
Aplicar función 0 pasando 2: -1
Aplicar función 1 pasando 2: 1.4142135623730951
Aplicar función 2 pasando 2: 2
Aplicar función 3 pasando 2: 0.6931471805599453</pre>

                    <p class="fragment">¿Puede reemplazarse la referencia a <code>factorial</code> por otra función anónima?</p>
                </section>

                <section>
                    <h4>Notación Lambda</h4>
                    <p>Existe una sintaxis más sencilla para denotar funciones anónimas.</p>
                    <p>En lugar de:</p>
                    <pre><code data-trim class="javascript">
function (x, y, z) { /* ... */ }                    
                    </code></pre>
                    <p>Puede escribirse:</p>
                    <pre><code data-trim class="javascript">
(x, y, z) => { /* ... */ }                    
                    </code></pre>
                </section>

                <section>
                    <p>Si la función anónima solo tiene un parámetro pueden omitirse los paréntesis iniciales:</p>
                    <p>En lugar de:</p>
                    <pre><code data-trim class="javascript">
function (x) { console.log(`Valor recibido: ${x}`); }
                    </code></pre>
                    <p>Puede escribirse:</p>
                    <pre><code data-trim class="javascript">
x => { console.log(`Valor recibido: ${x}`); }                    
                    </code></pre>
                </section>

                <section>
                    <p>Además, si el cuerpo de la función es de la forma <code>return exp</code>, pueden omitirse las llaves y el <code>return</code>:</p>
                    <p>En lugar de:</p>
                    <pre><code data-trim class="javascript">
function (x) { return x + 1; }
                    </code></pre>
                    <p>Puede escribirse:</p>
                    <pre><code data-trim class="javascript">
x => x + 1
                    </code></pre>
                </section>

                <section>
                    <p>En el ejemplo anterior:</p>
                    <pre><code data-trim class="javascript">
aplicar_funciones(
    [ x => x - 3,
      x => Math.sqrt(x),
      factorial,
      x => Math.log(x)  ], 2);
                    </code></pre>
                    <p>o incluso:</p>
                    <pre><code data-trim class="javascript">
aplicar_funciones([x => x - 3, Math.sqrt, factorial, Math.log ], 2);
                    </code></pre>
                </section>


                <section>
                    <h4>Clausuras</h4>
                    <p>Una función puede hacer referencia a variables declaradas en un ámbito superior</p>
                    <pre><code data-trim data-noescape class="javascript">
let y = 3;  // variable global

let f = (x => x + y); <span class="arrow_box_left caja_codigo fragment">Referencia a la variable global y</span>

console.log(f(5));
// Imprime: 8
                    </code></pre>
                    <div class="fragment">
                        <p>¿Y si cambio el valor de la variable <code>y</code> después de definir <code>f</code>?</p>
                        <pre class="fragment"><code data-trim class="javascript">
y = 9;
console.log(f(2));
// Imprime: 11
                    </code></pre>
                    </div>
                </section>

                <section>
                    <h4>Funciones dentro de objetos</h4>
                    <p>Como las funciones son ciudadanos de primera clase, pueden ser asignadas a los atributos de un objeto:</p>
                    <pre><code data-trim data-noescape class="javascript">
var empleado = {
  nombre: "Manuel",
  saludar: function() { 
        console.log("¡Hola!"); <span class="arrow_box_left caja_codigo fragment">¡No utilizar expresiones lambda aquí!</span>
  } 
};

empleado.saludar();
    // &rarr; ¡Hola!
                    </code></pre>
                    <p class="fragment">Este tipo de funciones reciben el nombre de <strong>métodos</strong>.</p>
                    <div class="fragment">
                        <p>Se puede añadir métodos a un objeto ya construido:</p>
                        <pre><code data-trim class="javascript">
empleado.despedir = function() { console.log("¡Adios!"); };
empleado.despedir();
                    </code></pre>
                    </div>
                </section>

                <section>
                    <h4>El objeto <code style="text-transform:none">this</code></h4>
                    <p style="font-family:monospace">
                        <span style="background-color:#A4A430; padding:2px; border-radius: 6px">empleado</span>.<span style="background-color:#B080B0; padding:2px; border-radius: 6px">saludar</span>();
                    </p>
                    <p>En toda llamada a método se distinguen tres componentes:</p>
                    <ul>
                        <li class="fragment">Método llamado: <span style="background-color:#B080B0; padding:2px; border-radius: 6px; font-family:monospace">saludar</span></li>
                        <li class="fragment">Argumentos (ninguno, en este caso)</li>
                        <li class="fragment">Objeto sobre el que se realiza la llamada: <span style="background-color:#A4A430; padding:2px; border-radius: 6px; font-family:monospace">empleado</span></li>
                    </ul>
                    <p class="fragment">Cuando llamamos a un método, éste recibe, además de los correspondientes argumentos, una variable especial (<code>this</code>) que contiene una referencia al objeto sobre el que se realiza la llamada.</p>
                </section>

                <section>
                    Ejemplo:
                    <pre><code data-trim data-noescape class="javascript">
var empleado = {
    nombre: "Manuel",

    saludar: function() {
        console.log(`¡Hola, ${<span style="background-color:#D4D430; padding:2px; border-radius: 6px">this</span>.nombre}!`);
    }

    cambiarNombre: function(nuevoNombre) {
        <span style="background-color:#D4D430; padding:2px; border-radius: 6px">this</span>.nombre = nuevoNombre;
    }
};
                    </code></pre>

                    <pre><code data-trim class="javascript">
empleado.saludar();
    // &rarr; ¡Hola, Manuel!

empleado.cambiarNombre("Irene");

empleado.saludar();
    // &rarr; ¡Hola, Irene!
                    </code></pre>

                </section>

                <section>
                    <p>Pueden transferirse métodos entre distintos objetos: </p>
                    <pre><code data-trim data-noescape class="javascript">
var otro_empleado = {
    nombre: "David",
    saludar: empleado.saludar
};

<span style="background-color:#D4D430; padding:2px; border-radius: 6px">otro_empleado</span>.saludar();
    // &rarr; ¡Hola, <span style="background-color:#D4D430; padding:2px; border-radius: 6px">David</span>!
                    </code></pre>
                    <p>Se imprime el nombre de <code>otro_empleado</code>, porque es el objeto que recibe la llamada, aunque se llame a un método proveniente de otro objeto.</p>
                    <div class="fragment">
                        <p>¿Qué ocurre al ejecutar el siguiente código?</p>
                        <pre><code data-trim class="javascript">
var f = empleado.saludar;
f();
                    </code></pre>
                    </div>
                </section>
                

                <section>
                    <p>Podemos encapsular la creación de objetos mediante funciones constructoras:</p>
                    <pre><code data-trim class="javascript">
function construirComplejo(real, imag) {
    return {
        r : real,
        i : imag,

        modulo: function() {
            return Math.sqrt(this.r * this.r + this.i * this.i);
        },

        argumento: function() {
            return Math.atan2(this.i, this. r);
        }

    }
}

var c1 = construirComplejo(-3, 0);
console.log(c1.argumento());  // &rarr; 3.141592653589793
var c2 = construirComplejo(1, 1);
console.log(c2.modulo());     // &rarr; 1.4142135623730951
                    </code></pre>
                    <p style="font-size:60%" class="fragment">(Más adelante veremos otra forma de crear funciones constructoras)</p>
                </section>

                <section>
                    <p>Problema: duplicidad de objetos función para cada objeto.</p>
                    <img src="images/03/DosComplejos.svg" style="height:100%; border:none">
                    <p class="fragment">¿No podrían <code>c1</code> y <code>c2</code> compartir los métodos?</p>
                </section>

                <section>
                    <p>Posible solución:</p>
                    <pre><code data-trim class="javascript">
function moduloComplejo() {
    return Math.sqrt(this.r * this.r + this.i * this.i);
}

function argumentoComplejo() {
    return Math.atan2(this.i, this. r);
}

function construirComplejo(real, imag) {
    return {
        r : real,
        i : imag,
        modulo: moduloComplejo,
        argumento: argumentoComplejo
    }
}
                    </code></pre>
                </section>

                <section>
                    <img src="images/03/DosComplejosComparten.svg" style="width:95%; border:none">
                </section>

                <section>
                    <p>Ahora añadimos un método nuevo a <code>c1</code>:</p>
                    <pre><code data-trim class="javascript">
var c1 = construirComplejo(-3, 0);
var c2 = construirComplejo(1, 1);

// ...

c1.coordenadasPolares = function() {
    console.log(`(${this.modulo()}, ${this.argumento()})`);
}
                    </code></pre>
                    <p>Este método existe solamente dentro de <code>c1</code>.</p>
                    <div style="background-color: #F0D0D0" class="fragment">
                        <p>¿Existe alguna manera de añadir un método simultáneamente a todos los objetos que hubiesen sido creados mediante <code>construirComplejo</code>?</p>
                        <p class="fragment">Sí. Se puede hacer mediante <strong>prototipos</strong>.</p>
                    </div>
                </section>
            </section>

            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 7</span><span style="display:none">:</span><br>La herencia basada en prototipos</h3>
                    </div>
                </section>


                <section>
                    <h4>Prototipo de un objeto</h4>
                    <p>Todo objeto en Javascript tiene un puntero &laquo;secreto&raquo; que puede apuntar a otro objeto:</p>
                    <img src="images/03/ComplejoPrototipo.svg" style="width:40%;border:none;box-shadow:none">
                    <div class="fragment">
                        <p>... o puede ser un puntero nulo:</p>
                        <img src="images/03/ComplejoPrototipo2.svg" style="width:23%;border:none;box-shadow:none">
                    </div>
                </section>

                <section>
                    <img src="images/03/CadenaPrototipos1.svg" style="width:50%;border:none;box-shadow:none">
                    <p>En el primer caso decimos que el objeto apuntado es <strong>prototipo</strong> de <code>c1</code>.</p>
                </section>

                <section>
                    <p>A su vez, el prototipo de <code>c1</code> puede tener otro prototipo:</p>
                    <img src="images/03/CadenaPrototipos2.svg" style="width:80%;border:none;box-shadow:none">
                    <p>De este modo tenemos una <strong>cadena de prototipos</strong>, que acabará en un objeto no tenga prototipo.</p>
                </section>

                <section>
                    <h4>Búsqueda de atributos</h4>
                    <p>¿Qué ocurre cuando se accede al atributo de un objeto?</p>
                    <p>Supongamos la expresión <code>c1.nombre</code></p>
                </section>

                <section data-transition="slide-in fade-out">
                    <p><code>c1.nombre</code></p>
                    <img src="images/03/CadenaPrototipos3.svg" style="width:80%;border:none;box-shadow:none">
                    <p>En primer lugar se intenta buscar un atributo llamado <code>nombre</code> dentro de <code>c1</code>.</p>
                </section>

                <section data-transition="fade-in fade-out">
                    <p><code>c1.nombre</code></p>
                    <img src="images/03/CadenaPrototipos4.svg" style="width:80%;border:none;box-shadow:none">
                    <p>Si no se encuentra en <code>c1</code>, se busca el atributo dentro del prototipo de <code>c1</code>.</p>
                </section>

                <section data-transition="fade-in slide-out">
                    <img src="images/03/CadenaPrototipos5.svg" style="width:80%;border:none;box-shadow:none">
                    <p>Si no se encuentra en el prototipo de <code>c1</code>, se busca dentro del prototipo del prototipo de <code>c1</code>. Si no se encuentra allí, la búsqueda continúa por la cadena de prototipos hasta que:
                    </p>
                    <ul>
                        <li>Se encuentre el atributo en algún objeto de la cadena.</li>
                        <li>Se llegue al final de la cadena. En este caso la expresión <code>c1.nombre</code> se evalúa a <code>undefined</code>.</li>
                    </ul>

                </section>

                <section>
                    <h4>Crear objetos que apunten a un prototipo</h4>
                    <p>Se utiliza la función <code>Object.create()</code></p>
                    <p>La siguiente sentencia:</p>
                    <pre><code data-trim class="javascript">
let y = Object.create(x);
                    </code></pre>
                    <p>crea un objeto <code>y</code> que tiene a <code>x</code> como prototipo:</p>
                    <img src="images/03/PrototiposXY.svg" style="width:50%;border:none;box-shadow:none">
                </section>

                <section>
                    Ejemplo:
                    <pre><code data-trim class="javascript">
let circulo = {
    centro: { x: 10, y: 20 },
    radio: 5
};

let circulo_verde = Object.create(circulo);
circulo_verde.color = "verde";


let circulo_rojo = Object.create(circulo);
circulo_rojo.color = "rojo";
                    </code></pre>

                    <pre class="fragment"><code data-trim data-noescape class="javascript">
console.log(circulo_rojo.color);        <span class="fragment">// &rarr; "rojo"</span>
console.log(circulo_verde.radio);       <span class="fragment">// &rarr; 5</span>
console.log(circulo_verde.centro.x);    <span class="fragment">// &rarr; 10</span>
console.log(circulo_rojo.centro);       <span class="fragment">// &rarr; { x: 10, y: 20 }</span>
                    </code></pre>

                </section>

                <section>
                    <h4>Cambiar y añadir atributos al prototipo</h4>
                    <p>Añadimos lo siguiente al ejemplo anterior:</p>
                    <pre><code data-trim class="javascript">
                    circulo.grosorBorde = 2;
                    </code></pre>
                    <p>¿Qué ocurre con <code>circulo_verde</code> y <code>circulo_rojo</code>?</p>
                    <pre><code data-trim data-noescape class="javascript">
console.log(circulo_rojo.grosorBorde);      <span class="fragment">// &rarr; 2</span>
console.log(circulo_verde.grosorBorde);     <span class="fragment">// &rarr; 2</span>
                    </code></pre>
                    <p class="fragment">&laquo;Heredan&raquo; automáticamente el nuevo atributo.</p>
                    <div class="fragment">
                        <p>Lo mismo ocurre con las modificaciones al prototipo:</p>
                        <pre><code data-trim class="javascript">
circulo.radio = 6;

console.log(circulo_rojo.radio);    // &rarr; 6
console.log(circulo_verde.radio);   // &rarr; 6
                    </code></pre>
                    </div>
                </section>

                <section>
                    <h4>Sobreescritura de atributos</h4>
                    <p>Un objeto puede sobreescribir cualquier atributo heredado de su prototipo:</p>
                    <pre><code data-trim class="">
circulo_rojo.radio = 3;
                    </code></pre>
                    <pre><code data-trim data-noescape class="javascript">
console.log(circulo_rojo.radio);    <span class="fragment">// &rarr; 3</span>
console.log(circulo_verde.radio);   <span class="fragment">// &rarr; 6</span>
                    </code></pre>
                    <p class="fragment">El atributo sobreescrito no afecta a los demás objetos que tengan el mismo prototipo.</p>
                </section>

                <section>
                    <p><code>circulo_rojo.radio = 3;</code></p>
                    <img src="images/03/CirculosRojoyVerde.svg" style="width:60%;border:none;box-shadow:none">
                    <div class="fragment">
                        <p>¿Qué ocurre con lo siguiente?</p>
                        <pre><code data-trim class="javascript">
circulo_rojo.centro.x = 15;
console.log(circulo_verde.centro.x);
                    </code></pre>
                    </div>
                </section>

                <section>
                    <p>Volviendo al ejemplo de los números complejos</p>
                    <img src="images/03/DosComplejosComparten.svg" style="width:95%; border:none">
                </section>

                <section>
                    <pre><code data-trim data-noescape class="javascript">
let prototipoComplejo = {
    function modulo() {
        return Math.sqrt(this.r * this.r + this.i * this.i);
    },
    function argumento() {
        return Math.atan2(this.i, this. r);
    }
};


function construirComplejo(real, imag) {
    var resultado = <span class="hl">Object.create(prototipoComplejo)</span>;
    resultado.r = real;
    resultado.i = imag;
    return resultado;
}
                    </code></pre>
                    <pre><code data-trim class="javascript">
var c1 = construirComplejo(-3, 0);
var c2 = construirComplejo(1, 1);
                    </code></pre>
                </section>


                <section>
                    <p>Todas las funciones que se añadan al prototipo estarán disponibles automáticamente para todos los objetos que hayan sido creados previamente por <code>construirComplejo</code></p>
                    <pre><code data-trim class="javascript">
// Añadimos una nueva función al prototipo:

prototipoComplejo.coordenadasPolares = () => {
  console.log(`(${this.modulo()}, ${this.argumento()})`);
}

c1.coordenadasPolares();
    // &rarr; (3, 3.141592653589793)

c2.coordenadasPolares();
    // &rarr; (1.4142135623730951, 0.7853981633974483)
                    </code></pre>
                </section>

                <section>
                    <h4>El objeto <code style="text-transform:none">Object.prototype</code></h4>
                    <p>Por defecto, un objeto tiene como prototipo <code>Object.prototype</code>.</p>
                    <p><code>Object.prototype</code> tiene algunos métodos predefinidos:</p>
                    <ul>
                        <li><code>toString()</code></li>
                        <li><code>valueOf()</code></li>
                        <li><code>isPrototypeOf()</code></li>
                        <li><code>hasOwnProperty()</code></li>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype">[+]</a></li>
                    </ul>
                </section>

                <section>
                    <h4>Ejemplos</h4>
                    <pre><code data-trim data-noescape class="javascript">
let c3 = construirComplejo(1, 3);

console.log(c3.toString());
    // &rarr; [object Object]
<span class="fragment">
prototipoComplejo.toString = function() {
    return "(" + this.r + ", " + this.i + ")";
}

console.log(c3.toString());
    // &rarr; (1, 3)</span>
                    </code></pre>
                    <pre class="fragment"><code data-trim class="javascript">
console.log(prototipoComplejo.isPrototypeOf(c3));
    // &rarr; true
                    </code></pre>
                </section>

            </section>

            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 8</span><span style="display:none">:</span><br>Las clases en Javascript llegaron veinte años tarde</h3>
                    </div>
                </section>

                <section>
                    <p>Recordemos nuestro ejemplo sobre números complejos</p>
                    <pre><code data-trim data-noescape class="javascript">
let prototipoComplejo = {
    function modulo() {
        return Math.sqrt(this.r * this.r + this.i * this.i);
    },
    function argumento() {
        return Math.atan2(this.i, this. r);
    }
};


function construirComplejo(real, imag) {
    var resultado = <span class="hl">Object.create(prototipoComplejo)</span>;
    resultado.r = real;
    resultado.i = imag;
    return resultado;
}
                    </code></pre>
                    <pre><code data-trim class="javascript">
var c1 = construirComplejo(-3, 0);
var c2 = construirComplejo(1, 1);
                    </code></pre>
                </section>

                <section>
                    <p>La situación queda representada así:</p>
                    <img src="images/03/PrototipoComplejo.svg" class="noborder" style="width:90%">
                </section>

                <section>
                    <p>Este patrón es bastante común en Javascript para simular las <strong>clases</strong> de otros lenguajes de programación:</p>
                    <ul>
                        <li>Tener un objeto prototipo que almacene los métodos de la clase.</li>
                        <li>Tener una función que construya las instancias de la clase, enlazándolas con el prototipo.</li>
                    </ul>

                    <div class="fragment">
                        <p>Era un patrón tan común que Javascript proporcionaba mecanismos para facilitar su uso.</p>
                        <ul>
                            <li>ECMAScript &leq; 5: funciones constructoras + operador <code>new</code>.</li>
                            <li>ECMAScript &geq; 6: clases + operador <code>new</code>.</li>
                        </ul>
                    </div>

                </section>

                <section>
                    <h4>Clases</h4>
                    <p>Las clases de ECMAScript 6 son similares a las de Java:</p>
                    <pre><code data-trim data-noescape class="javascript">
class Complejo {
    constructor(real, imag) {   <span class="arrow_box_left caja_codigo fragment">Constructora de clase</span>
        this.r = real;
        this.i = imag;
    }

    modulo() {   <span class="arrow_box_left caja_codigo fragment">Método</span>
        return Math.sqrt(this.r * this.r + this.i * this.i);
    }

    argumento() {   <span class="arrow_box_left caja_codigo fragment">Método</span>
        return Math.atan2(this.i, this.r);
    }
}</code></pre>
                    <p>Esta declaración crea un objeto llamado <code>Complejo.prototype</code> que almacena estos dos métodos.</p>
                </section>

                <section>
                    <p>Al igual que en Java, se crean instancias mediante el operador <code>new</code>.</p>
                    <pre><code data-trim data-noescape class="javascript">
let c1 = new Complejo(-3, 0);
let c2 = new Complejo(1, 1);
                    </code></pre>
                    <p>Esto hace que los objetos <code>c1</code> y <code>c2</code> tengan a <code>Complejo.prototype</code> como prototipo.</p>
                    <pre><code data-trim data-noescape class="javascript">
console.log(c1.modulo());  // &rarr; 3
console.log(c2.modulo());  // &rarr; 1.4142135623730951
</code></pre>
                </section>

                <section>
                    <img src="images/03/PrototipoComplejo2.svg" class="noborder" style="width:90%">
                </section>

                <section>
                    <h4>El operador <code style="text-transform:none">instanceof</code></h4>
                    <p>La expresión <code>x instanceof C</code> se evalúa a <code>true</code> si el objeto <code>C.prototype</code> es alcanzable ascendiendo desde <code>x</code> en la cadena de prototipos:</p>
                    <pre><code data-trim data-noescape class="javascript">
var x = new Complejo(-3, 0);

console.log(x instanceof Complejo); <span class="fragment">// &rarr; true</span>
console.log(x instanceof Object);   <span class="fragment">// &rarr; true</span>
console.log(x instanceof Number);   <span class="fragment">// &rarr; false</span>
                    </code></pre>
                </section>

                <section>
                    <h4>Funciones <code>get</code>/<code>set</code></h4>
                    <p>Son funciones llamadas cada vez que se lee o escribe a un determinado atributo.</p>
                    <pre><code data-trim data-noescape class="javascript">
class Complejo {
    // ...
    <span class="hl">get</span> modulo() {      <span class="arrow_box_left caja_codigo fragment">Método get</span>
      return Math.sqrt(this.r * this.r + this.i * this.i);
    }
    
    <span class="hl">set</span> modulo(newModulo) {         <span class="arrow_box_left caja_codigo fragment">Método set</span>
      console.log("Llamando a set modulo");
      if (newModulo >= 0 && this.modulo > 0) {
        let scaleFactor = newModulo / this.modulo;
        this.r *= scaleFactor;
        this.i *= scaleFactor;
      }
    }
}
                    </code></pre>
                </section>

                <section>
                    <p>Cada vez que se accede al atributo <code>modulo</code>, en realidad se llama a la función <code>get</code>:</p>
                    <pre><code data-trim data-noescape class="javascript">
let c1 = new Complejo(1, 1);
console.log(c1.modulo);     // Imprime: 1.4142135623730951
                    </code></pre>
                    <p>Cada vez que se modifica <code>modulo</code>, en realidad se llama a la función <code>set</code>, pasando por parámetro el valor asignado.</p>
                    <pre><code data-trim data-noescape class="javascript">
c1.modulo = 3;
console.log(c1.r);     // Imprime: 2.1213203435596424
                    </code></pre>
                </section>


                <section>
                    <p>Esto es útil para encapsular el acceso a atributos:</p>
                    <pre><code data-trim data-noescape class="javascript">
class Persona {
    constructor(nombre, edad) {
        this.nombre = nombre;
        this._edad = edad;  <span class="arrow_box_left caja_codigo fragment">Atributo &laquo;privado&raquo;</span>
    }

    get edad() {
        return this._edad;
    }

    set edad(newEdad) {
        if (newEdad >= 0) {
            this._edad = newEdad;
        }
    }
}                    
                    </code></pre>

                    <pre><code data-trim data-noescape class="javascript">
let p = new Persona("Elena", 23);
p.edad = -2;            // No modifica la edad
console.log(p.edad);    // Imprime: 23         
                    </code></pre>
                </section>

                <section>
                    <h4>Métodos estáticos</h4>
                    <p>Son métodos de clase.</p>
                    <p>Van precedidos por la palabra <code>static</code>.</p>

                    <pre><code data-trim data-noescape class="javascript">
class Complejo {
    // ...

    <span class="hl">static</span> desdePolar(mod, arg) {
        var real = mod * Math.cos(arg),
            imag = mod * Math.sin(arg);
        return new Complejo(real, imag);
    }    
}
                    </code></pre>
                    <pre><code data-trim data-noescape class="javascript">
let c2 = Complejo.desdePolar(1, Math.PI / 4);
console.log(c2.r);  // Imprime 0.7071067811865476
                    </code></pre>
                </section>

                <section>
                    <p>Es posible añadir métodos estáticos una vez declarada la clase:</p>
                    <pre><code data-trim data-noescape class="javascript">
Complejo.desdePolar = (mod, arg) => {
    // ...
}

Complejo.CERO = new Complejo(0, 0);   <span class="arrow_box_left caja_codigo fragment">Atributos estáticos</span>
                    </code></pre>
                </section>


                <section>
                    <h4>Herencia</h4>
                    <p>Se permite herencia simple, al igual que en Java.</p>
                    <pre><code data-trim data-noescape class="javascript">
class Persona {
    constructor(nombre, edad) { ... }
    ...
}

class Empleado extends Persona {
    constructor(nombre, edad, sueldo) {
        super(nombre, edad);
        this.sueldo = sueldo;
    }
    ...
}
</code></pre>

                    <pre><code data-trim data-noescape class="javascript">
let e = new Empleado("Elena", 23, 2000);
console.log(e.edad);    // Imprime: 23
console.log(e.sueldo);  // Imprime: 2000
</code></pre>
                </section>

                <section>
                    <p>Al decir que <code>Empleado</code> extiende a <code>Persona</code>, estamos encadenando el prototipo de persona con el de empleado.
                    </p>
                    <img src="images/03/CadenaHerencia.svg" style="width:90%" class="noborder">
                </section>

                <section>
                    <p>Si no se indica cláusula <code>extends</code>, la clase hereda automáticamente de <code>Object</code></p>
                    <img src="images/03/CadenaHerencia2.svg" style="width:70%" class="noborder">
                </section>

                <section>
                    <p>Podemos sobreescribir métodos heredados:</p>
                    <pre><code data-trim data-noescape class="javascript">
class Complejo {
    // ...
    
    toString() {
        return `(${this.r}, ${this.i})`;
    }
    
}
</code></pre>
                    <p>El método <code>toString</code> está heredado de <code>Object</code>.</p>
                    <pre><code data-trim data-noescape class="javascript">
let c1 = new Complejo(-1, 0);
console.log(`El número es ${c1}`);  // Imprime: El número es (-1, 0)
</code></pre>
                </section>

            </section>


            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 9</span><span style="display:none">:</span><br>Los arrays son flexibles, y también son objetos</h3>
                    </div>
                </section>

                <section>
                    <h4>Inicialización de arrays</h4>
                    <p>
                        Un array puede inicializarse enumerando sus elementos,
                    </p>
                    <pre><code data-trim class="javascript">
let a = [23, 12, 69, 11, 34, 45];
                    </code></pre>
                    <div class="fragment">
                        <p>o bien mediante el constructor <code>Array</code>:</p>
                        <pre><code data-trim class="javascript">
let b = new Array(10);
// Todos los elementos tienen el valor 'undefined'
                    </code></pre>
                    </div>
                </section>

                <section>
                    <h4>Los arrays son objetos</h4>
                    <p>Es posible asignar propiedades arbitrarias a un array.</p>
                    <pre><code data-trim class="javascript">
let a = [23, 12, 69, 11, 34, 45];
a.estaOrdenado = false;

console.log(a);
    // &rarr; [ 1, 5, 3, 5, 4, esta_ordenado: false ]
                    </code></pre>

                    <p class="fragment">Todos los arrays extienden a la clase <code>Array</code>, que contiene algunos métodos de utilidad sobre arrays. <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/prototype">[+]</a></p>
                </section>

                <section>
                    <h4>Los arrays son flexibles y pueden tener &laquo;huecos&raquo;</h4>
                    <p>Puede variarse la longitud de un array en tiempo de ejecución. Basta con modificar la propiedad <code>length</code>:</p>
                    <pre><code data-trim class="javascript">
let a = [23, 12, 69, 11, 34, 45];
a.length += 2;  // Ampliamos el array

console.log(a); // &rarr; [ 23, 12, 69, 11, 34, 45, ,  ]

a.length = 3;  // Reducimos el array

console.log(a); // &rarr; [ 23, 12, 69 ]
                    </code></pre>
                    <div class="fragment">
                        <p>También se puede ampliar el array añadiendo elementos fuera de su rango:</p>
                        <pre><code data-trim class="javascript">
a[5] = 32;
console.log(a); // &rarr; [ 23, 12, 69, , , 32 ]
                    </code></pre>
                    </div>
                </section>

                <section>
                    <p>Métodos que modifican el tamaño del array:</p>
                    <ul>
                        <li>
                            <code>push(x)</code>
                            <br> Inserta <code>x</code> al final del array.
                        </li>
                        <li>
                            <code>pop()</code>
                            <br> Elimina y devuelve el último elemento del array.
                        </li>
                        <li>
                            <code>unshift(x)</code>
                            <br> Añade <code>x</code> al principio del array, desplazando los restantes elementos.
                        </li>
                        <li>
                            <code>shift()</code>
                            <br> Elimina el primer elemento del array, desplazando los restantes elementos.
                        </li>
                        <li>
                            <code>splice(ini, num)</code> Partiendo del elemento en la posición <code>ini</code>, elimina <code>num</code> elementos.
                        </li>
                    </ul>
                </section>

                <section>
                    <p>Ejemplo:</p>
                    <pre><code data-trim data-noescape class="javascript">
let a = [1, 2, 3, 4, 5];
    <span class="fragment">// a = [1, 2, 3, 4, 5];</span>

a.push(8);
    <span class="fragment">// a = [1, 2, 3, 4, 5, 8];</span>

a.unshift(-4);
    <span class="fragment">// a = [-4, 1, 2, 3, 4, 5, 8];</span>

a.pop(); // &rarr; 8
    <span class="fragment">// a = [-4, 1, 2, 3, 4, 5];</span>

a.shift(); // &rarr; -4
    <span class="fragment">// a = [1, 2, 3, 4, 5];</span>

a.splice(2, 2); <span class="fragment">// &rarr; [3, 4]</span>
    <span class="fragment">// a = [1, 2, 5];</span>
                    </code></pre>
                </section>

                <section>
                    <p>Otras operaciones destructivas:</p>
                    <pre><code data-trim class="javascript">
a = [4, 7, 4, 1, 3, 5];
a.sort();
    // a = [1, 3, 4, 4, 5, 7]

a.reverse();
    // a = [7, 5, 4, 4, 3, 1]
                    </code></pre>
                </section>

                <section>
                    <p>Operaciones no destructivas:</p>
                    <ul>
                        <li>
                            <code>concat(arr_1, ..., arr_n)</code>
                            <br> Añade los arrays pasados como argumento y devuelve el resultado.
                            <pre><code data-trim class="javascript">
[1, 2, 3].concat([4, 5], [6, 7, 8]);
    // &rarr; [1, 2, 3, 4, 5, 6, 7, 8]

                            </code></pre>
                        </li>
                        <li>
                            <code>slice(ini, fin)</code>
                            <br> Devuelve el segmento <code>[ini, fin)</code> del array.
                            <pre><code data-trim class="javascript">
["a", "b", "c", "d", "e", "f", "g"].slice(2, 5);
    // &rarr; ["c", "d", "e"]
                            </code></pre>
                        </li>
                    </ul>
                </section>

                <section>
                    <ul>
                        <li>
                            <code>join(sep)</code>
                            <br> Concatena los elementos del array intercalando
                            <code>sep</code> como separador:
                            <pre><code data-trim class="javascript">
["Esto", "no", "me", "gusta"].join(" - ");
    // &rarr; "Esto - no - me - gusta"
                            </code></pre>
                        </li>
                    </ul>
                </section>

                <section>
                    <p>Búsqueda de valores:</p>
                    <ul>
                        <li><code>indexOf(elem, [pos_inicial])</code>
                            <p>Devuelve el índice de la última aparición de <code>elem</code> en el array, o -1 si no se encuentra.</p>
                        </li>
                        <li><code>lastIndexOf(elem)</code>
                            <p>Devuelve el índice de la última aparición de <code>elem</code> en el array, o -1 si no se encuentra.</p>
                        </li>
                    </ul>
                </section>

            </section>

            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 10</span><span style="display:none">:</span><br>Las funciones de orden superior sobre arrays</h3>
                    </div>
                </section>

                <section>
                    <h4>Funciones de orden superior</h4>
                    <p>Una función de <strong>orden superior</strong> es una función que recibe funciones como parámetro y/o devuelve funciones.</p>
                    <p>Javascript proporciona varios métodos de orden superior para arrays que son muy útiles en la práctica.</p>
                </section>

                <section>
                    <h4>Iteración: método <code style="text-transform:none">forEach</code></h4>
                    <ul>
                        <li>
                            <code>forEach(f)</code>
                            <br> Aplica la función <code>f</code> sobre todos los elementos del array.
                        </li>
                        <pre><code data-trim class="javascript">
let personas = [ { nombre: "Ricardo", edad: 45},
                 { nombre: "Julia", edad: 24 },
                 { nombre: "Ashley", edad: 28 } ];

personas.forEach(p => {
    console.log("Hola, me llamo " + p.nombre
                + " y tengo " + p.edad + " años");
})

                        </code></pre>
                    </ul>
                </section>


                <section>
                    <h4>Funciones de transformación</h4>
                    <ul>
                        <li>
                            <code>map(f)</code>
                            <br> Aplica la función <code>f</code> a cada elemento del array, devolviendo otro array con los resultados.
                            <pre><code data-trim class="javascript">
let a = [1, 3, 5, 2, 4];
let dobles = a.map(n => n * 2);
console.log(dobles); // [2, 6, 10, 4, 8]
                            </code></pre>
                        </li>
                        <li class="fragment">
                            <code>filter(f)</code>
                            <br> Selecciona los elementos <code>x</code> del array tales que <code>f(x)</code> devuelve <code>true</code>.
                            <pre><code data-trim class="javascript">
let pares = a.filter(n => n % 2 === 0);
console.log(pares); // [2, 4]
                            </code></pre>
                        </li>
                    </ul>

                </section>

                <section>
                    <h4>Funciones de reducción (I)</h4>
                    <ul>
                        <li>
                            <code>every(f)</code>
                            <br> Devuelve <code>true</code> si para <em>todo</em> elemento <code>x</code> del array, <code>f(x)</code> devuelve <code>true</code>.
                        </li>
                        <li>
                            <code>some(f)</code>
                            <br> Devuelve <code>true</code> si <em>existe</em> un elemento <code>x</code> en el array tal que <code>f(x)</code> devuelva <code>true</code>.
                        </li>
                    </ul>
                </section>

                <section>
                    <h4>Funciones de reducción (II)</h4>
                    <ul>
                        <li>
                            <code>reduce(f, [elemInicial])</code>
                            <br> Recorre el array de izquierda a derecha, acumulando un valor durante el recorrido.
                        </li>
                        <pre><code data-trim class="javascript">
let a = [2, 6, 9, 1];

console.log(
    "Valor final: " +
    a.reduce((acum, n) => 2 * acum + n, 7)
);  // &rarr; 171

                        </code></pre>
                    </ul>
                </section>

                <section>
                    <p><img src="images/03/Reduce1.svg" style="width:100%; border:none; box-shadow:none"></p>
                </section>

                <section>
                    <h4>Otros ejemplos</h4>
                    <p>Suma de los elementos de un array</p>
                    <pre><code data-trim class="javascript">
[1, 5, 7, 4].reduce((ac, n) => ac + n, 0)
                    </code></pre>
                    <img src="images/03/Reduce2.svg" style="width:80%;border:none; box-shadow:none">
                </section>

                <section>
                    <h4>Otros ejemplos</h4>
                    <p>Multiplicación de los elementos de un array</p>
                    <pre><code data-trim class="javascript">
[1, 5, 7, 4].reduce((ac, n) => ac * n, 1)
                    </code></pre>

                    <p>Máximo de los elementos de un array</p>
                    <pre><code data-trim data-noescape class="javascript">
[6, 1, 4, 3, 7].reduce((acum, x) => Math.max(acum, x), -Infinity);

<span class="fragment">// o bien
[6, 1, 4, 3, 7].reduce(Math.max, -Infinity);</span>
                    </code></pre>
                </section>

                <section>
                    <h4>Variantes</h4>
                    <p><code>reduce(f, [ini])</code></p>
                    <p>Si no se indica valor inicial, se supone que éste es el primer elemento del array.</p>
                    <pre><code data-trim class="javascript">
[1, 5, 7, 4].reduce((acum, x) => acum + x)
                    </code></pre>
                    <img src="images/03/Reduce3.svg" style="width:80%;border:none; box-shadow:none">
                </section>

                <section>
                    <h4>La función reductora</h4>
                    <p><code>reduce(f, [ini])</code></p>
                    <p>La función <code>f</code> puede recibir hasta cuatro parámetros:</p>
                    <ol>
                        <li>Valor acumulado hasta el momento.</li>
                        <li>Elemento actual del array.</li>
                        <li>Índice actual del array.</li>
                        <li>Array sobre el que se está haciendo el <code>reduce</code>.</li>
                    </ol>
                </section>

                <section>
                    <h4>Variantes</h4>
                    <p><code>reduceRight(f, [ini])</code></p>
                    <p>Realiza lo mismo que <code>reduce</code>, pero recorriendo el vector de derecha a izquierda.</p>
                </section>

            </section>


            <section>
                <section>
                    <div class="bloquetitulo" style="padding:20px">
                        <h3><span class="titulo_rareza">Rareza 11</span><span style="display:none">:</span><br>los módulos aún están por aterrizar</h3>
                    </div>
                </section>
                <section>
                    <p>
                        Hasta la versión 6 de ECMAScript, el estándar no había especificado ningún sistema para estructurar los programas Javascript complejos en módulos.
                    </p>
                    <p>
                        En versiones anteriores podían simularse módulos utilizando otros mecanismos disponibles en el lenguaje.
                    </p>
                    <p>
                        En temas posteriores veremos dos de estos mecanismos:
                    </p>
                    <ul>
                        <li><strong>CommonJS</strong>, utilizado en <em>Node.js</em>.</li>
                        <li><strong>AMD</strong> (<em>Asynchronous Module  Definition</em>), utilizado en los navegadores.</li>
                    </ul>
                </section>

                <section>
                    <p>Pese a que el sistema de módulos está definido en ECMAScript 6 (2015), los navegadores solo lo soportan de manera experimental.</p>
                    <p>Por este motivo no lo utilizaremos en este curso.</p>
                </section>

            </section>
            
            <section>
                <h3>Y la lista de rarezas no acaba aquí</h3>
                <ul>
                    <li>Número no prefijado de argumentos (<code>...args</code>).</li>
                    <li>Operador de propagación (<code>...</code>).</li>
                    <li>La clase <code>Symbol</code>.</li>
                    <li>Destructuración mediante patrones.</li>
                    <li>Iteradores.</li>
                    <li>Funciones generadoras (<code>function*</code>).</li>
                </ul>
                <p>Más información: <a href="http://exploringjs.com/es6.html">http://exploringjs.com/es6.html</a></p>
                
            </section>

            <section data-background-image="images/RedBackground.jpg" data-background-transition="zoom" id="p4">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline">Introducción</a></li>
                    <li><a href="#/p2" class="outline">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline current">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>

            <section>
                <h2>Clases estándar</h2>
                <p>El estándar de ECMAScript define las siguientes clases
                    <br>(disponibles tanto en Node como en los navegadores)</p>
                <ul>
                    <li>Manejo de expresiones regulares</li>
                    <li>Manejo de fechas</li>
                    <li>Trazas y <em>logging</em></li>
                    <li>Utilidades varias</li>

                </ul>
            </section>

            <section>
                <section>
                    <h3>Expresiones regulares</h3>
                    <p>Una expresión regular es un patrón que representa una o varias cadenas de texto.</p>
                    <p>Por ejemplo, la expresión regular <code>[A-Z][0-9]{3}</code> denota el conjunto de cadenas que comienzan por una letra mayúscula y van seguidas por tres dígitos</p>
                    <p style="font-size:80%">Ejs: <code>A324</code>, <code>F983</code>, etc.</p>
                    <p class="fragment">Ver: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">Lenguaje de expresiones regulares</a></p>
                </section>

                <section>
                    <p>En Javascript se delimitan las expresiones regulares por símbolos <code>/</code></p>
                    <pre><code data-trim class="javascript">
var expr = /[A-Z][0-9]{3}/;
                </code></pre>
                    <p class="fragment">Las expresiones regulares son objetos con los siguientes métodos:</p>
                    <ul>
                        <li class="fragment">
                            <code>test(str)</code>: Devuelve <code>true</code> si en la cadena <code>str</code> existe una subcadena que encaja con la expresión, o <code>false</code> en caso contrario.
                        </li>
                        <li class="fragment">
                            <code>exec(str)</code>: También comprueba el ajuste de alguna subcadena de <code>str</code> con el patrón, pero devuelve más información sobre el ajuste producido (o <code>null</code> si no hay ajuste).
                        </li>
                    </ul>
                </section>

                <section>
                    <h4>Método <code style="text-transform:none">test</code></h4>
                    <pre><code data-trim data-noescape class="javascript">
/[A-Z][0-9]{3}/.test("A655");
    <span class="fragment">// &rarr; true</span>
/[A-Z][0-9]{3}/.test("Otra cosa");
    <span class="fragment">// &rarr; false</span>

/el|la|los|las/.test("Esta frase tiene un artículo");
    <span class="fragment">// &rarr; false</span>
/el|la|los|las/.test("Esta clase tiene un artículo");
    <span class="fragment">// &rarr; true</span>
/\b(el|la|los|las)\b/.test("Esta clase tiene un artículo");
    <span class="fragment">// &rarr; false</span>
            </code></pre>
                    <p>El símbolo <code>\b</code> representa el límite de una palabra.</p>
                </section>

                <section>
                    <h4>Método <code style="text-transform:none">exec</code></h4>
                    <p>A veces podemos dividir la expresión regular en varios grupos con el fin de saber qué parte de la cadena capturada corresponde a cada grupo.</p>
                    <p>Cada grupo va delimitado entre paréntesis <code>(</code>, <code>)</code></p>
                    <p>La función <code>exec</code> nos permite desglosar cualquier cadena que ajuste con el patrón en sus distintos grupos.</p>
                </section>

                <section>
                    <p>Por ejemplo, la siguiente expresión:</p>
                    <code>\d{4}\-[A-Z]{3}</code>
                    <div class="fragment">
                        <p>ajusta con cualquier secuencia de cuatro dígitos (<code>\d</code> = digito) que vaya seguida de un guión (<code>\-</code>) y tres letras mayúsculas.</p>
                        <p style="font-size:80%">Ejs: <code>0249-GSW</code>, <code>1934-HHG</code>, etc.</p>
                    </div>
                    <div class="fragment">
                        <p>Si queremos poder separar la secuencia de dígitos de la de letras utilizamos dos grupos:</p>
                        <code>(<span style="background-color:#FFFF70;border-radius:10px">\d{4}</span>)\-(<span style="background-color:#A0FFFF;border-radius:10px">[A-Z]{3}</span>)</code>
                    </div>
                </section>

                <section>
                    <pre><code data-trim class="javascript">
var regexp = /(\d{4})\-([A-Z]{3})/;
var result = regexp.exec("Mi matrícula de coche es 8367-AWD");
                </code></pre>
                    <p>La subcadena <code><span style="background-color:#FFFF70;border-radius:10px">8367</span>-<span style="background-color:#A0FFFF;border-radius:10px">AWD</span></code> ajusta con el patrón <code>regexp</code>, pero <code>exec</code> nos permite saber qué fragmento de ésta ajusta con cada grupo</p>
                    <pre><code data-trim data-noescape class="javascript">

result[0] <span class="fragment">// &rarr; "8367-AWD" (Cadena completa)</span>
result[1] <span class="fragment">// &rarr; "8367"     (Primer grupo de captura)</span>
result[2] <span class="fragment">// &rarr; "AWD"      (Segundo grupo de captura)</span>

result.index <span class="fragment">// &rarr; 25   (Posición del ajuste dentro de la cadena)</span>
                </code></pre>
                </section>

                <section>
                    <h4>Modificadores de expresiones regulares</h4>
                    <p>Se colocan tras el delimitador <code>/</code> final de la expresión.</p>
                    <table style="border:1px solid black">
                        <tr>
                            <td><code>i</code></td>
                            <td>No distingue entre mayúsculas y minúsculas.</td>
                        </tr>
                        <tr>
                            <td><code>g</code></td>
                            <td>Ajuste global.
                                <br> Permite encontrar varias ocurrencias en la misma cadena.</td>
                        </tr>
                        <tr>
                            <td><code>m</code></td>
                            <td>Buscar a lo largo de varias líneas.
                                <br> Varía el comportamiento de <code>^</code> y <code>$</code>.
                            </td>
                        </tr>
                    </table>
                </section>

                <section>
                    <h4>Ejemplos</h4>
                    <pre><code data-trim data-noescape class="javascript">
var r1 = /Hola/i;
r1.test("hola") <span class="fragment">// &rarr; true</span>

var str = "Hola, hola\nHola caracola";

str.match(/hola/);
    <span class="fragment">// &rarr; [ 'hola', index: 6, ... ]</span>
str.match(/hola/i);
    <span class="fragment">// &rarr; [ 'Hola', index: 0, ... ]</span>

// La búsqueda global encuentra todos los resultados
str.match(/hola/gi);
    <span class="fragment">// &rarr; [ 'Hola', 'hola', 'Hola' ]</span>

// El carácter ^ significa 'principio de cadena'
str.match(/^Hola/g);
    <span class="fragment">// &rarr; [ 'Hola' ]</span>

// Pero con el modificador 'm' significa 'principio de línea'
str.match(/^Hola/gm);
    <span class="fragment">// &rarr; [ 'Hola', 'Hola' ]</span>
                </code></pre>
                </section>

                <section>
                    <h4>Métodos de cadenas relacionados con expresiones regulares</h4>
                    <ul>
                        <li><code>match(regexp)</code>
                            <br> Devuelve todas las subcadenas que ajustan con la expresión regular <code>regexp</code> (si ésta contiene el modificador <code>g</code>) o solamente la primera (en caso contrario).
                        </li>
                        <li><code>search(regexp)</code>
                            <br> Devuelve el índice de la primera subcadena que ajuste con <code>regexp</code>, o -1 si no hay ninguna.
                        </li>
                        <li><code>replace(regexp, nuevaCadena)</code> Reemplaza por <code>nuevaCadena</code> las subcadenas que ajusten con <code>regexp</code>.
                        </li>
                        <li><code>split(regexp)</code> Divide la cadena en fragmentos, utilizando <code>regexp</code> como separador.
                        </li>
                    </ul>
                </section>

                <section>
                    <h4>Sobre la función <code style="text-transform:none">replace</code></h4>
                    <p><code>replace(regexp, nuevaCadena)</code></p>
                    <p>La cadena de reemplazo (<code>nuevaCadena</code>) puede hacer referencia a los grupos de captura de la expresión regular.</p>
                    <pre><code data-trim class="javascript">
var r = /(\d{4})\-([A-Z]{3})/;
var str = "Mi número de matrícula es 9483-GSD";

str.replace(r, "$2/$1");
    // &rarr; "Mi número de matrícula es GSD/9483"
                </code></pre>
                </section>

            </section>
            <section>
                <h3>Los objetos <code style="text-transform:none">Date</code></h3>
                <p>Sirven para realizar operaciones con fechas y horas.</p>
                <pre><code data-trim class="javascript">
var ahora = new Date();
ahora.toString();
    // &rarr; 'Fri Oct 14 2016 14:37:56 GMT+0200 (CEST)'
ahora.getFullYear();
    // &rarr; 2016
ahora.getMonth();
    // &rarr; 9
ahora.getSeconds();
    // &rarr; 56

var fechaInicio = new Date(2016, 09, 26);
fechaInicio.toString();
    // &rarr; 'Wed Oct 26 2016 00:00:00 GMT+0200 (CEST)'
                </code></pre>
                <p>Más información: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date">[+]</a></p>
            </section>

            <section>
                <h3>El objeto <code style="text-transform:none">Math</code></h3>
                <p>Utilidades matemáticas varias:</p>
                <ul>
                    <li>Constantes: <code>E</code>, <code>LN2</code>, <code>PI</code>, etc.
                    </li>
                    <li>Máximos y mínimos: <code>max</code>, <code>min</code>.</li>
                    <li>Números aleatorios: <code>random</code>.</li>
                    <li>Redondeo: <code>ceil</code>, <code>floor</code>, <code>trunc</code>, <code>round</code>, etc.</li>
                    <li>Potencias: <code>pow</code>, <code>sqrt</code>, <code>cbrt</code>, etc.</li>
                    <li>Trigonométricas: <code>sin</code>, <code>sinh</code>, <code>cos</code>, etc.</li>
                    <li>Exponenciales y logarítmicas: <code>exp</code>, <code>log</code>, <code>log10</code>, etc.</li>
                </ul>

            </section>

            <section>
                <h3>El objeto <code style="text-transform:none">console</code></h3>
                <p>Tiene, entre otros, los métodos:</p>
                <ul>
                    <li><code>log(str)</code>
                        <br> Muestra mensajes de depuración.
                    </li>
                    <li><code>warn(str)</code>
                        <br> Muestra mensajes de aviso.
                    </li>
                    <li><code>error(str)</code>
                        <br> Muestra mensajes de error.
                    </li>
                    <li><code>assert(cond, str)</code>
                        <br> Lanza un <code>AssertionError(str)</code> si <code>cond</code> no se cumple.
                    </li>
                </ul>
            </section>


            <section>
                <section>
                    <h3>Estructuras de datos: <code>Map</code> y <code>Set</code></h3>
                    <p>Recordemos que un <strong>objeto</strong> en Javascript no es más que una asociación de atributos con valores.</p>
                    <p>Esto se parece mucho al TAD Diccionario visto en EDA...</p>
                    <p>En Java: <code>HashMap</code>, <code>TreeMap</code>, etc.</p>
                    <p>Los atributos de un objeto pueden hacer el rol de las claves de un diccionario. ¿Podríamos implementar un diccionario utilizando objetos?</p>
                </section>

                <section>
                    <pre><code data-trim data-noescape class="javascript">
class Diccionario {
    constructor() {
        this.dict = {};
    }
    
    insertar(clave, valor) {
        this.dict[clave] = valor;
    }
    
    buscar(clave) {
        return this.dict[clave];
    }
    
    contieneClave(clave) {
        return this.dict[clave] !== undefined;
    }
}
</code></pre>

                </section>

                <section>
                    <pre><code data-trim data-noescape class="javascript">
let d = new Diccionario();
d.insertar(1, "Mireia");
d.insertar(2, "David");
d.buscar(2);           // &rarr; David
d.contieneClave(2);    // &rarr; 2
d.contieneClave(3);   // &rarr; 3 
</code></pre>
                    <p>Hasta aquí todo funciona bien.</p>
                    <div style="color:#5050FF" class="fragment">
                        <p>Pero esta implementación tiene un fallo... y gordo.</p>
                        <p>¿Qué problema tiene?</p>
                    </div>
                </section>

                <section>
                    <p>Para evitar estos problemas, Javascript viene con una clase <code>Map</code> que implementa correctamente los diccionarios.</p>
                    <pre><code data-trim data-noescape class="javascript">
let dicc = new Map();
dicc.set(1, "Mireia");
dicc.set(2, "David");
dicc.get(2);            // &rarr; David
dicc.has(2);            // &rarr; true
dicc.has("toString");   // &rarr; false

dicc.forEach((valor, clave) => {
    console.log(`${clave} ===> ${valor}`)
});
// Imprime: 
//  1 ==> Mireia
//  2 ==> David
</code></pre>
                    <p>Más información: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Map/prototype">Map.prototype</a></p>
                </section>

                <section>
                    <p>También se proporciona una implementación del TAD de los conjuntos (<code>Set</code>).</p>
                    <pre><code data-trim data-noescape class="javascript">
let conj = new Set();
[25, 12, 27, 12, 90].forEach(x => conj.add(x));
conj.has(25);       // &rarr; true
conj.delete(12);
conj.size           // &rarr; 4
 
conj.forEach(v => { console.log(v) });
</code></pre>
                    <p>Convertir un conjunto en lista:</p>
                    <pre><code data-trim data-noescape class="javascript">
let lista = [..conj];
// Sumamos todos los elementos del conjunto:
lista.reduce((ac, x) => ac + x);   // &rarr; 154
</code></pre>
                </section>

            </section>


            <section data-background-image="images/RedBackground.jpg" data-background-transition="zoom" id="p5">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline">Introducción</a></li>
                    <li><a href="#/p2" class="outline">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline current">Herramientas</a></li>
                    <li><a href="#/p7" class="outline">Bibliografía</a></li>
                </ol>
            </section>

            <section>
                <h2>Utilidades y herramientas</h2>
                <ul>
                    <li>JSDoc
                        <br>
                        <a href="http://usejsdoc.org/">http://usejsdoc.org/</a>
                    </li>
                    <li>Depuradores</li>
                    <li>Herramientas de <em>testing</em></li>
                </ul>
            </section>

            <section>
                <section>
                    <h3>JSDoc</h3>
                    <p>Herramienta de generación de documentación, al estilo de <em>Javadoc</em></p>
                    <pre><code data-trim class="javascript">
/**
 * Las instancias de esta clase representan números complejos.
 */
class Complejo {
    /**
     * Construye un número complejo a partir de sus partes real
     * e imaginaria.
     *
     * Puede construirse un número a partir de su forma polar
     * mediante la función {@link Complejo.desdePolar}
     *
     * @param {number} real Parte real
     * @param {number} imag Parte imaginaria
     */
    constructor(real, imag) { ... }
    
    // ...
}
                </code></pre>
                </section>

                <section>
                    <img src="images/03/JSDoc.png" style="width:80%;border:none">
                </section>
            </section>

            <section>
                <section>
                    <h2>Depuradores</h2>
                    <p>Existen herramientas de depuración incorporadas, tanto en el entorno del cliente como en el del servidor.</p>
                    <ul>
                        <li><strong>Lado del servidor</strong> (Node)
                            <br> La depuración se realiza mediante un <em>shell</em> lanzado desde la línea de comandos, o bien con <em>node-inspector</em>, que proporciona una interfaz gráfica:<br> <a href="https://www.npmjs.com/package/node-inspector">https://www.npmjs.com/package/node-inspector</a>

                        </li>
                        <li><strong>Lado del cliente</strong> (Navegador)
                            <br> Las herramientas para desarrolladores integradas en Firefox y Chrome proporcionan un depurador.

                        </li>
                    </ul>
                </section>

                <section>
                    <p>En cualquiera de los dos entornos puede introducirse un punto de ruptura mediante la siguiente sentencia:</p>
                    <pre><code data-trim class="javascript">
debugger;
                </code></pre>
                </section>

                <section>
                    <h4>Ejemplo</h4>
                    <pre><code data-trim class="javascript">
// sum_square.js
// -------------
// Este programa calcula la suma de cuadrados
// del array 'arr'.

let sum = 0;
let arr = [1, 4, 8, 1, 3];

debugger; // Punto de ruptura

for (let i = 0; i &lt; array.length; i++) {
    sum += arr[i] * arr[i];
}

console.log(sum);
                </code></pre>
                </section>

                <section>
                    <h4>Iniciar depuración con Node</h4>
                    <pre><code data-trim class="no-highlight">
node debug sum_squares.js
                </code></pre>
                    <div class="fragment">
                        <h4>Comandos</h4>
                        <table>
                            <tr>
                                <td><code>cont</code></td>
                                <td>Salta al siguiente punto de ruptura</td>
                            </tr>
                            <tr>
                                <td><code>step</code></td>
                                <td rowspan="2" style="vertical-align:middle">Avanzar paso (metiéndose dentro de funciones o no)</td>
                            </tr>
                            <tr>
                                <td><code>next</code></td>
                            </tr>
                            <tr>
                                <td><code>repl</code></td>
                                <td>Arrancar <em>shell</em> para evaluar expresiones</td>
                            </tr>
                            <tr>
                                <td><code>watch("..")</code></td>
                                <td>Visualizar expresión en cada paso de ejecución</td>
                            </tr>
                        </table>
                    </div>
                </section>

                <section>
                    <h4>Depuración con Node</h4>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/tckK4F38FaU" frameborder="0" allowfullscreen></iframe>
                </section>

                <section>
                    <h4>Depuración con Node-inspector</h4>
                    Requiere instalación previa mediante la herramienta <code>npm</code>, distribuida junto con Node (ver Tema 4).
                    <pre><code data-trim class="no-highlight">
npm install -g node-inspector
                </code></pre> Tras la instalación ejecutar:
                    <pre><code data-trim data-noescape class="no-highlight">
node-debug <em>fichero.js</em>
                </code></pre> y se abrirá un navegador con una interfaz gráfica de depuración.
                </section>

                <section>
                    <p>Ejemplo:</p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/CGGBUdnM3G0" frameborder="0" allowfullscreen></iframe>
                </section>

                <section>
                    <h4>Depuración con Firefox</h4>
                    <p><em>Desarrollador</em> &rarr; <em>Depurador</em> (Ctrl+Mayús+S)</p>
                    <iframe width="560" height="315" src="https://www.youtube.com/embed/fxU3ByrhSmc" frameborder="0" allowfullscreen></iframe>
                </section>
            </section>

            <section>
                <section>
                    <h3>Frameworks de testing</h3>
                    <ul>
                        <li><strong>Mocha</strong>
                            <br>
                            <a href="https://mochajs.org/">https://mochajs.org/</a>
                        </li>
                        <li><strong>Jasmine</strong>
                            <br>
                            <a href="http://jasmine.github.io/">http://jasmine.github.io/</a>
                        </li>
                        <li><strong>Chai</strong>
                            <br>
                            <a href="http://chaijs.com/">http://chaijs.com/</a>
                        </li>
                    </ul>
                </section>

                <section>
                    <h4>Ejemplo: Mocha</h4>
                    <p>El siguiente módulo contiene un error en la función <code>insert</code></p>
                    <pre><code data-trim data-noescape class="javascript">
/* Inserta el elemento arr[i] en la porción del array comprendida
   entre los índices 0 y i-1, suponiendo que dicha porción está
   ordenada */
function insert(i, arr) {
    var j = i;
    while (j > 1 &amp;&amp; arr[j] &lt; arr[j - 1]) {  <span class="arrow_box_left caja_codigo fragment">¡error!</span>
        swap(arr, j, j - 1);
        j = j - 1;
    }
}

/* Implementación del algoritmo de ordenación por inserción */
function insertionSort(arr) {
    for (var i = 1; i &lt; arr.length; i++) {
        insert(i, arr);
    }
}

module.exports = {
    insertionSort : insertionSort,
    insert        : insert
}
                </code></pre>
                </section>


                <section>
                    <p>Creamos una carpeta <code>test</code> y añadimos el siguiente fichero <code>insert_test.js</code>:
                        <pre><code data-trim class="javascript">
//...
describe("Prueba de ordenación por inserción", () => {
    it("Ordenación de array ascendente", () => {
        let arr = [1, 2, 3, 4];
        testing.insertionSort(arr);
        assert.deepEqual(arr, [1, 2, 3, 4]);
    });

    it("Ordenación de array descendente", () => {
        let arr = [8, 4, 2];
        testing.insertionSort(arr);
        assert.deepEqual(arr, [2, 4, 8]);
    });
    
    it("Inserción en array desordenado", () => {
        let arr = [3, 2];
        testing.insert(1, arr);
        assert.deepEqual(arr, [2, 3]);
    });
});
                </code></pre>
                </section>

                <section>
                    <p>Ejecutamos los casos de prueba:</p>
                    <pre><code data-trim data-noescape class="no-highlight">
# <span style="background-color:#C0C0FF">mocha</span>
...
  2 failing

  1) Prueba de ordenación por inserción
       Ordenación de array descendente:

      AssertionError: <span style="background-color:#e6bbbb">[ 8, 2, 4 ] deepEqual [ 2, 4, 8 ]</span>
      + expected - actual

       [
      -  8    <span class="arrow_box_left caja_codigo">Sobra esto</span>
         2
         4
      +  8    <span class="arrow_box_left caja_codigo">Falta esto</span>
       ]
      
                </code></pre>
                </section>

                <section>
                    <p>Tras corregir el error:</p>
                    <pre><code data-trim data-noescape class="javascript">
function insert(i, arr) {
    ...
    while (j > 0 &amp;&amp; arr[j] &lt; arr[j - 1]) {
    ...
}
                </code></pre>
                    <pre><code data-trim data-noescape class="no-highlight">
# <span style="background-color:#C0C0FF">mocha</span>

  Prueba de ordenación por inserción
    ✓ Ordenación de array ascendente
    ✓ Ordenación de array descendente
    ✓ Inserción en array desordenado


  <span style="background-color:#C0FFC0">3 passing (8ms)</span>
                </code></pre>
                </section>
            </section>

            <section data-background-image="images/RedBackground.jpg" data-background-transition="zoom" id="p7">
                <ol class="contenidos" style="width:13em">
                    <li><a href="#/p1" class="outline">Introducción</a></li>
                    <li><a href="#/p2" class="outline">Javascript es como Java...</a></li>
                    <li><a href="#/p3" class="outline">...pero no es como Java</a></li>
                    <li><a href="#/p4" class="outline">Clases estándar</a></li>
                    <li><a href="#/p5" class="outline">Herramientas</a></li>
                    <li><a href="#/p7" class="outline current">Bibliografía</a></li>
                </ol>
            </section>

            <section>
                <h2>Bibliografía</h2>
                <div style="float:left; width:70%">
                    <ul>
                        <li>A. Rauschmayer
                            <br>
                            <a href="http://cisne.sim.ucm.es/record=b3513723~S6*spi">Speaking Javascript</a>
                            <br> O'Reilly (2014)
                        </li>
                        <li>E. Brown
                            <br>
                            <a href="http://cisne.sim.ucm.es/record=b3579629~S6*spi">Learning Javascript, 3rd edition</a>
                            <br> O'Reilly (2016)
                        </li>
                        <li>
                            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference">Javascript Reference</a>
                            <br>MDN - Mozilla Developer Network
                            <br><span style="font-size:50%">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference</span>
                        </li>
                    </ul>
                </div>
                <div style="float:right; width: 30%">
                    <img src="http://speakingjs.com/speakingjs_cover.jpg" style="width:50%; border:none">
                    <img src="http://akamaicovers.oreilly.com/images/0636920035534/cat.gif" style="width:50%; border:none">
                </div>

            </section>


        </div>

    </div>


    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
        // More info https://github.com/hakimel/reveal.js#configuration
        Reveal.initialize({
            history: true,
            slideNumber: true,

            // More info https://github.com/hakimel/reveal.js#dependencies
            dependencies: [{
                src: 'plugin/markdown/marked.js'
            }, {
                src: 'plugin/markdown/markdown.js'
            }, {
                src: 'plugin/notes/notes.js',
                async: true
            }, {
                src: 'plugin/highlight/highlight.js',
                async: true,
                callback: function() {
                    hljs.initHighlightingOnLoad();
                }
            }]
        });

    </script>
</body>

</html>
